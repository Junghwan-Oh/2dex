import os
import ssl
import requests
from typing import Dict, Any, Optional, List, Callable

import certifi

BASE_URL = "https://api.telegram.org/bot"

class TelegramBot:
    def __init__(self, token: str, chat_id: str, base_url: Optional[str] = None):
        self.token = token
        self.chat_id = chat_id
        self.base_url = base_url if base_url else BASE_URL
        self.api_url = f"{self.base_url.rstrip('/')}{self.token}"

        # Create session with SSL context
        self.session = requests.Session()
        self.session.verify = certifi.where()
        self.session.timeout = 10

        # For receiving commands
        self.lastUpdateId = 0
        self.stopCommands = ['stop', 'kill', '/stop', '/kill', 'STOP', 'KILL']
        self.menuCommands = ['/menu', '/help', 'menu', 'help']

        # Command handlers (will be set by HedgeBot)
        self.commandHandlers: Dict[str, Callable] = {}

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
    
    def close(self):
        """close requests session"""
        if self.session:
            self.session.close()

    def send_text(self, content: str, parse_mode: str = "HTML") -> Dict[str, Any]:
        """Send a text message to Telegram"""
        payload = {
            "chat_id": self.chat_id,
            "text": content,
            "parse_mode": parse_mode
        }
        return self._send_message("sendMessage", payload)

    def _send_message(self, method: str, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Internal method to send messages to Telegram API"""
        url = f"{self.api_url}/{method}"

        try:
            response = self.session.post(url, json=payload)
            response_data = response.json()
            if not response_data.get("ok", False):
                print(f"Telegram send message failed: {response_data}")
            return response_data
        except Exception as e:
            print(f"Telegram send message failed: {e}")
            return {"ok": False, "error": str(e)}

    def getUpdates(self, timeout: int = 0) -> list:
        """Get updates (incoming messages) from Telegram API"""
        url = f"{self.api_url}/getUpdates"
        params = {"timeout": timeout}
        if self.lastUpdateId > 0:
            params["offset"] = self.lastUpdateId + 1

        try:
            response = self.session.get(url, params=params, timeout=timeout + 10)
            responseData = response.json()
            if responseData.get("ok", False):
                return responseData.get("result", [])
            return []
        except Exception as e:
            print(f"Telegram getUpdates failed: {e}")
            return []

    def checkForStopCommand(self) -> bool:
        """Check if a stop/kill command was received from authorized chat"""
        updates = self.getUpdates()

        for update in updates:
            updateId = update.get("update_id", 0)
            if updateId > self.lastUpdateId:
                self.lastUpdateId = updateId

            message = update.get("message", {})
            chatId = str(message.get("chat", {}).get("id", ""))
            text = message.get("text", "").strip()

            # Only process commands from authorized chat
            if chatId == str(self.chat_id):
                if text.lower() in [cmd.lower() for cmd in self.stopCommands]:
                    return True

        return False
