#!/usr/bin/env python3
"""
Delta Neutral (DN) Hedge Mode: Backpack + GRVT

Usage:
    python DN_alternate_backpack_grvt.py --ticker SOL --size 1 --iter 10
    python DN_alternate_backpack_grvt.py --ticker SOL --size 1 --iter 10 --primary-mode bbo_minus_1 --hedge-mode market
"""

import asyncio
import signal
import logging
import os
import sys
import time
import csv
import traceback
from decimal import Decimal
from typing import Tuple, Optional, List
from datetime import datetime
from enum import Enum
from dataclasses import dataclass, asdict, field
import pytz

# Import exchanges modules (like Mean Reversion bot)
from exchanges.backpack import BackpackClient
from exchanges.grvt import GrvtClient
# Paradex removed - replaced by Backpack


class PriceMode(Enum):
    BBO_MINUS_1 = "bbo_minus_1"
    BBO_PLUS_1 = "bbo_plus_1"
    BBO = "bbo"
    AGGRESSIVE = "aggressive"
    MARKET = "market"


class Config:
    def __init__(self, config_dict):
        for key, value in config_dict.items():
            setattr(self, key, value)


@dataclass
class TradeMetrics:
    """Metrics for tracking trade execution details."""
    iteration: int
    direction: str  # "BUY_FIRST" or "SELL_FIRST"

    # Entry prices
    primary_entry_price: Decimal
    hedge_entry_price: Decimal
    primary_entry_time: float  # timestamp
    hedge_entry_time: float

    # Exit prices
    primary_exit_price: Decimal
    hedge_exit_price: Decimal
    primary_exit_time: float
    hedge_exit_time: float

    # Timing measurements (milliseconds)
    order_to_fill_primary: float
    order_to_fill_hedge: float
    websocket_latency: float
    rest_latency: float
    reconciliation_time: float

    # Other metrics
    repricing_count: int
    total_cycle_time: float  # seconds

    def to_dict(self):
        """Convert to dictionary for CSV export."""
        d = asdict(self)
        # Convert Decimal to string for CSV
        for key, value in d.items():
            if isinstance(value, Decimal):
                d[key] = str(value)
        return d


class DNHedgeBot:
    def __init__(
        self,
        ticker: str,
        order_quantity: Decimal,
        fill_timeout: int = 5,
        iterations: int = 20,
        sleep_time: int = 0,
        max_position: Decimal = Decimal("0"),
        primary_exchange: str = "backpack",
        hedge_exchange: str = "grvt",
        primary_mode: PriceMode = PriceMode.BBO_MINUS_1,
        hedge_mode: PriceMode = PriceMode.MARKET,
        min_spread_bps: Decimal = Decimal("0"),
    ):
        self.ticker = ticker
        self.order_quantity = order_quantity
        self.fill_timeout = fill_timeout
        self.iterations = iterations
        self.sleep_time = sleep_time
        self.primary_exchange = primary_exchange.lower()
        self.hedge_exchange = hedge_exchange.lower()
        self.primary_mode = primary_mode
        self.hedge_mode = hedge_mode
        self.min_spread_bps = min_spread_bps
        self.strategy = "alternative"  # Fixed strategy for this file

        self.max_position = (
            order_quantity if max_position == Decimal("0") else max_position
        )

        os.makedirs("logs", exist_ok=True)
        self.log_filename = f"logs/DN_alternate_backpack_grvt_{self.ticker}_log.txt"
        self.csv_filename = f"logs/DN_alternate_backpack_grvt_{self.ticker}_trades.csv"

        self._initialize_csv_file()
        self._setup_logger()

        self.stop_flag = False
        self.order_counter = 0

        self.primary_position = Decimal("0")
        self.hedge_position = Decimal("0")

        self.local_primary_position = Decimal("0")
        self.local_hedge_position = Decimal("0")
        self.use_local_tracking = True
        self.reconcile_interval = 1  # Reconcile every cycle for tighter drift control

        self.primary_client = None
        self.hedge_client = None

        self.primary_contract_id = None
        self.primary_tick_size = None
        self.hedge_contract_id = None
        self.hedge_tick_size = None

        self.primary_order_status = None
        self.hedge_order_filled = False
        self.order_execution_complete = False
        self.waiting_for_hedge_fill = False

        self.current_hedge_side = None
        self.current_hedge_quantity = None
        self.current_hedge_price = None

        self.total_gross_pnl = Decimal("0")
        self.total_volume = Decimal("0")
        self.completed_cycles = 0

        # Trade metrics tracking
        self.trade_metrics_list: List[TradeMetrics] = []
        self.current_cycle_start_time = None
        self.repricing_count = 0

        # Current cycle metrics (reset each cycle)
        self.current_primary_entry_price = None
        self.current_hedge_entry_price = None
        self.current_primary_entry_time = None
        self.current_hedge_entry_time = None
        self.current_primary_exit_price = None
        self.current_hedge_exit_price = None
        self.current_primary_exit_time = None
        self.current_hedge_exit_time = None
        self.current_order_to_fill_primary = 0
        self.current_order_to_fill_hedge = 0
        self.current_websocket_latency = 0
        self.current_rest_latency = 0
        self.current_reconciliation_time = 0

    def _setup_logger(self):
        self.logger = logging.getLogger(f"dn_hedge_{self.ticker}")
        self.logger.setLevel(logging.INFO)
        self.logger.handlers.clear()

        for lib in ["urllib3", "requests", "websockets", "pysdk"]:
            logging.getLogger(lib).setLevel(logging.CRITICAL)
        logging.getLogger().setLevel(logging.CRITICAL)

        file_handler = logging.FileHandler(self.log_filename)
        file_handler.setLevel(logging.INFO)
        file_handler.setFormatter(
            logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
        )

        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(logging.INFO)
        console_handler.setFormatter(logging.Formatter("%(levelname)s: %(message)s"))

        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
        self.logger.propagate = False

    def _initialize_csv_file(self):
        if not os.path.exists(self.csv_filename):
            with open(self.csv_filename, "w", newline="") as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(
                    [
                        "exchange",
                        "timestamp",
                        "side",
                        "price",
                        "quantity",
                        "order_type",
                        "mode",
                    ]
                )

    def log_trade_to_csv(
        self,
        exchange: str,
        side: str,
        price: str,
        quantity: str,
        order_type: str = "hedge",
        mode: str = "",
    ):
        timestamp = datetime.now(pytz.UTC).isoformat()
        with open(self.csv_filename, "a", newline="") as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(
                [exchange, timestamp, side, price, quantity, order_type, mode]
            )

    def export_trade_metrics(self):
        """Export trade metrics to CSV file for analysis."""
        if not self.trade_metrics_list:
            self.logger.info("[EXPORT] No trade metrics to export")
            return

        timestamp_str = datetime.now(pytz.UTC).strftime("%Y%m%d_%H%M%S")
        metrics_filename = f"logs/trade_metrics_{self.primary_exchange}_{self.hedge_exchange}_{self.ticker}_{timestamp_str}.csv"

        try:
            with open(metrics_filename, "w", newline="") as csvfile:
                fieldnames = TradeMetrics.__dataclass_fields__.keys()
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()

                for metrics in self.trade_metrics_list:
                    writer.writerow(metrics.to_dict())

            self.logger.info(f"[EXPORT] Trade metrics exported to {metrics_filename}")
            self.logger.info(f"[EXPORT] Total {len(self.trade_metrics_list)} cycles exported")
        except Exception as e:
            self.logger.error(f"[EXPORT] Failed to export trade metrics: {e}")
            import traceback
            self.logger.error(f"[EXPORT] Traceback: {traceback.format_exc()}")

    def print_trade_summary(
        self,
        cycle_num: int,
        primary_side: str,
        primary_price: Decimal,
        hedge_side: str,
        hedge_price: Decimal,
        quantity: Decimal,
    ):
        if primary_side == "buy":
            spread = hedge_price - primary_price
            spread_bps = (spread / primary_price) * Decimal("10000")
        else:
            spread = primary_price - hedge_price
            spread_bps = (spread / hedge_price) * Decimal("10000")

        gross_pnl = spread * quantity
        self.total_gross_pnl += gross_pnl
        self.total_volume += quantity * primary_price
        self.completed_cycles += 1

        avg_pnl_bps = (
            (self.total_gross_pnl / self.total_volume) * Decimal("10000")
            if self.total_volume > 0
            else Decimal("0")
        )

        self.logger.info(
            f"\n{'-' * 55}\n"
            f"  CYCLE {cycle_num} COMPLETE\n"
            f"{'-' * 55}\n"
            f"  BACKPACK: {primary_side.upper():4} @ ${primary_price:.3f}\n"
            f"  GRVT:    {hedge_side.upper():4} @ ${hedge_price:.3f}\n"
            f"  Spread: ${spread:.4f} ({spread_bps:+.2f} bps)\n"
            f"  Cycle PnL: ${gross_pnl:.4f}\n"
            f"{'-' * 55}\n"
            f"  CUMULATIVE: {self.completed_cycles} cycles | PnL: ${self.total_gross_pnl:.4f} | Avg: {avg_pnl_bps:+.2f} bps\n"
            f"{'-' * 55}"
        )

    async def cleanup_connections(self):
        if self.hedge_client:
            try:
                await self.hedge_client.disconnect()
            except Exception:
                pass
        if self.primary_client:
            try:
                await self.primary_client.disconnect()
            except Exception:
                pass

    def shutdown(self, signum=None, frame=None):
        self.stop_flag = True
        self.logger.info("\n[SHUTDOWN] Stopping DN Hedge Bot...")

        try:
            loop = asyncio.get_running_loop()
            loop.create_task(self.cleanup_connections())
        except RuntimeError:
            pass

        for handler in self.logger.handlers[:]:
            try:
                handler.close()
                self.logger.removeHandler(handler)
            except Exception:
                pass

    def setup_signal_handlers(self):
        signal.signal(signal.SIGINT, self.shutdown)
        signal.signal(signal.SIGTERM, self.shutdown)

    def _create_exchange_config(self, ticker: str, quantity: Decimal) -> Config:
        return Config(
            {
                "ticker": ticker,
                "contract_id": "",
                "quantity": quantity,
                "tick_size": Decimal("0.01"),
                "close_order_side": "sell",
                "direction": "buy",
            }
        )

    def calculate_order_price(
        self,
        side: str,
        best_bid: Decimal,
        best_ask: Decimal,
        tick_size: Decimal,
        mode: PriceMode,
    ) -> Optional[Decimal]:
        if mode == PriceMode.MARKET:
            return None

        if side == "buy":
            if mode == PriceMode.BBO_MINUS_1:
                return best_bid - tick_size
            elif mode == PriceMode.BBO_PLUS_1:
                return best_bid + tick_size
            elif mode == PriceMode.AGGRESSIVE:
                return best_ask
            else:
                return best_bid
        else:
            if mode == PriceMode.BBO_MINUS_1:
                return best_ask + tick_size
            elif mode == PriceMode.BBO_PLUS_1:
                return best_ask - tick_size
            elif mode == PriceMode.AGGRESSIVE:
                return best_bid
            else:
                return best_ask

    async def check_arbitrage_opportunity(self, direction: str) -> bool:
        if self.min_spread_bps == Decimal("0"):
            return True

        primary_bid, primary_ask = await self.primary_client.fetch_bbo_prices(
            self.primary_contract_id
        )
        hedge_bid, hedge_ask = await self.hedge_client.fetch_bbo_prices(
            self.hedge_contract_id
        )

        if direction == "buy":
            spread_bps = (hedge_bid - primary_ask) / primary_ask * Decimal("10000")
        else:
            spread_bps = (primary_bid - hedge_ask) / hedge_ask * Decimal("10000")

        if spread_bps >= self.min_spread_bps:
            self.logger.info(
                f"[ARB] Spread: {spread_bps:.2f} bps >= {self.min_spread_bps} bps -> ENTER"
            )
            return True
        else:
            self.logger.info(
                f"[ARB] Spread: {spread_bps:.2f} bps < {self.min_spread_bps} bps -> SKIP"
            )
            return False

    async def initialize_clients(self):
        config = self._create_exchange_config(self.ticker, self.order_quantity)

        if self.primary_exchange == "backpack":
            self.primary_client = BackpackClient(config)
        elif self.primary_exchange == "grvt":
            self.primary_client = GrvtClient(config)
        else:
            raise ValueError(f"Unsupported primary exchange: {self.primary_exchange}")
        self.logger.info(
            f"[INIT] PRIMARY: {self.primary_exchange.upper()} (mode: {self.primary_mode.value})"
        )

        hedge_config = self._create_exchange_config(self.ticker, self.order_quantity)
        if self.hedge_exchange == "grvt":
            self.hedge_client = GrvtClient(hedge_config)
        # Paradex removed - no longer supported
        # elif self.hedge_exchange == "paradex":
        #     self.hedge_client = ParadexClient(hedge_config)
        else:
            raise ValueError(f"Unsupported hedge exchange: {self.hedge_exchange}")
        self.logger.info(
            f"[INIT] HEDGE: {self.hedge_exchange.upper()} (mode: {self.hedge_mode.value})"
        )

        (
            self.primary_contract_id,
            self.primary_tick_size,
        ) = await self.primary_client.get_contract_attributes()
        (
            self.hedge_contract_id,
            self.hedge_tick_size,
        ) = await self.hedge_client.get_contract_attributes()

        self.logger.info(
            f"[INIT] PRIMARY contract: {self.primary_contract_id}, tick: {self.primary_tick_size}"
        )
        self.logger.info(
            f"[INIT] HEDGE contract: {self.hedge_contract_id}, tick: {self.hedge_tick_size}"
        )

    async def connect_websockets(self):
        def primary_order_handler(order_data):
            self._handle_primary_order_update(order_data)

        self.primary_client.setup_order_update_handler(primary_order_handler)
        await self.primary_client.connect()
        self.logger.info(f"[WS] PRIMARY ({self.primary_exchange.upper()}) connected")

        await self.hedge_client.connect()
        self.logger.info(f"[WS] HEDGE ({self.hedge_exchange.upper()}) connected")

    def _handle_primary_order_update(self, order_data):
        if order_data.get("contract_id") != self.primary_contract_id:
            return

        try:
            order_id = order_data.get("order_id")
            status = order_data.get("status")
            side = order_data.get("side", "").lower()
            filled_size = Decimal(order_data.get("filled_size", "0"))
            price = order_data.get("price", "0")

            order_type = "OPEN" if side == "buy" else "CLOSE"

            if status == "CANCELED" and filled_size > 0:
                status = "FILLED"

            if status == "FILLED" and self.primary_order_status != "FILLED":
                if side == "buy":
                    self.primary_position += filled_size
                    self.local_primary_position += filled_size
                else:
                    self.primary_position -= filled_size
                    self.local_primary_position -= filled_size

                self.logger.info(
                    f"[{order_id}] [{order_type}] [{self.primary_exchange.upper()}] [FILLED]: "
                    f"{filled_size} @ {price}"
                )
                self.primary_order_status = status

                self.log_trade_to_csv(
                    exchange=self.primary_exchange.upper(),
                    side=side,
                    price=str(price),
                    quantity=str(filled_size),
                    order_type="primary",
                    mode=self.primary_mode.value,
                )

                hedge_side = "sell" if side == "buy" else "buy"
                self.current_hedge_side = hedge_side
                self.current_hedge_quantity = filled_size
                self.current_hedge_price = Decimal(price)
                self.waiting_for_hedge_fill = True

            elif self.primary_order_status != "FILLED":
                self.logger.info(
                    f"[{order_id}] [{order_type}] [{self.primary_exchange.upper()}] [{status}]: "
                    f"{order_data.get('size', filled_size)} @ {price}"
                )
                self.primary_order_status = status

        except Exception as e:
            self.logger.error(f"Error handling PRIMARY order update: {e}")

    async def get_positions(self, force_api: bool = False) -> Tuple[Decimal, Decimal]:
        if self.use_local_tracking and not force_api:
            # Use WebSocket positions for both exchanges (faster, no API calls)
            primary_ws_pos = self.primary_client.get_ws_position()
            hedge_ws_pos = self.hedge_client.get_ws_position()
            return primary_ws_pos, hedge_ws_pos

        primary_pos = await self.primary_client.get_account_positions()
        hedge_pos = await self.hedge_client.get_account_positions()
        return primary_pos, hedge_pos

    async def reconcile_positions(self):
        # Get WebSocket positions first (faster, no API calls)
        ws_primary = self.primary_client.get_ws_position()
        ws_hedge = self.hedge_client.get_ws_position()

        # Fallback to REST API if WebSocket positions seem stale or show significant mismatch
        # Changed to check ANY significant discrepancy (>0.001) not just when one side is 0
        position_discrepancy = abs(ws_primary - (-ws_hedge))  # Expected: primary + hedge = 0

        # Check ANY significant discrepancy first (aggressive detection)
        if position_discrepancy > Decimal("0.001"):
            self.logger.warning(
                f"[RECONCILE] Position discrepancy detected! P={ws_primary}, H={ws_hedge}, Diff={position_discrepancy}"
            )
            # Verify BOTH sides with REST API
            try:
                rest_primary = await self.primary_client.get_account_positions()
                rest_hedge = await self.hedge_client.get_account_positions()
                rest_discrepancy = abs(rest_primary - (-rest_hedge))

                if rest_discrepancy < position_discrepancy:
                    self.logger.warning(
                        f"[RECONCILE] REST API shows better balance! Using REST values: P={rest_primary}, H={rest_hedge}"
                    )
                    ws_primary = rest_primary
                    ws_hedge = rest_hedge
                    position_discrepancy = rest_discrepancy
            except Exception as e:
                self.logger.warning(f"[RECONCILE] Failed to fetch REST positions: {e}")

        # Fallback: Still check individual zero cases (legacy check)
        if ws_hedge == 0 and ws_primary != 0:
            # Potential WebSocket issue on hedge side, verify with REST API
            try:
                rest_hedge = await self.hedge_client.get_account_positions()
                if rest_hedge != 0:
                    self.logger.warning(
                        f"[RECONCILE] Hedge WS/REST mismatch! WS={ws_hedge}, REST={rest_hedge}, using REST"
                    )
                    ws_hedge = rest_hedge
            except Exception as e:
                self.logger.warning(
                    f"[RECONCILE] Failed to fetch REST hedge position: {e}"
                )

        if ws_primary == 0 and ws_hedge != 0:
            # Potential WebSocket issue on primary side, verify with REST API
            try:
                rest_primary = await self.primary_client.get_account_positions()
                if rest_primary != 0:
                    self.logger.warning(
                        f"[RECONCILE] Primary WS/REST mismatch! WS={ws_primary}, REST={rest_primary}, using REST"
                    )
                    ws_primary = rest_primary
            except Exception as e:
                self.logger.warning(
                    f"[RECONCILE] Failed to fetch REST primary position: {e}"
                )

        # Calculate net delta using WS values (real-time)
        ws_net_delta = ws_primary + ws_hedge

        self.logger.info(
            f"[RECONCILE] P(WS)={ws_primary}, H(WS)={ws_hedge}, NetDelta={ws_net_delta}"
        )

        # Sync local tracking with WS positions
        if abs(
            self.local_primary_position - ws_primary
        ) > self.order_quantity * Decimal("0.5"):
            self.logger.warning(
                f"[RECONCILE] Primary local/WS mismatch! Local={self.local_primary_position} WS={ws_primary}"
            )
            self.local_primary_position = ws_primary

        # Auto-recovery: If net delta exceeds absolute threshold, force sync and warn
        # Changed from percentage (1.5x) to absolute (0.01) for earlier drift detection
        if abs(ws_net_delta) > Decimal("0.01"):
            self.logger.warning(
                f"[RECONCILE] Net delta drift detected: {ws_net_delta}, initiating auto-recovery"
            )

            # Force REST API sync to correct position drift
            self.logger.info("[RECONCILE] Forcing position sync with REST API...")
            try:
                rest_primary = await self.primary_client.get_account_positions()
                rest_hedge = await self.hedge_client.get_account_positions()

                # Update local position tracking
                if hasattr(self.primary_client, '_local_position'):
                    self.primary_client._local_position = rest_primary
                    self.logger.info(f"[RECONCILE] Primary synced: {rest_primary}")
                if hasattr(self.hedge_client, '_local_position'):
                    self.hedge_client._local_position = rest_hedge
                    self.logger.info(f"[RECONCILE] Hedge synced: {rest_hedge}")

                # Recalculate with synced positions
                ws_primary = rest_primary
                ws_hedge = rest_hedge
                ws_net_delta = ws_primary + ws_hedge
                self.logger.info(f"[RECONCILE] After sync: Primary={ws_primary}, Hedge={ws_hedge}, NetDelta={ws_net_delta}")
            except Exception as e:
                self.logger.error(f"[RECONCILE] Failed to force sync: {e}")

    async def place_primary_order(self, side: str, quantity: Decimal) -> Optional[str]:
        self.primary_order_status = None

        best_bid, best_ask = await self.primary_client.fetch_bbo_prices(
            self.primary_contract_id
        )
        order_price = self.calculate_order_price(
            side, best_bid, best_ask, self.primary_tick_size, self.primary_mode
        )

        self.logger.info(
            f"[OPEN] [{self.primary_exchange.upper()}] [{side.upper()}] "
            f"POST_ONLY @ {order_price} (mode: {self.primary_mode.value})"
        )

        attempt = 0
        while not self.stop_flag:
            attempt += 1
            if attempt > 20:
                self.logger.error(
                    f"[OPEN] Failed to place order after {attempt} attempts"
                )
                return None

            try:
                # Backpack/GRVT use string "buy"/"sell" directly
                order_side = side

                order_result = await self.primary_client.place_post_only_order(
                    contract_id=self.primary_contract_id,
                    quantity=quantity,
                    price=order_price,
                    side=order_side,
                )

                if order_result and order_result.order_id:
                    order_id = order_result.order_id
                    actual_price = (
                        order_result.price
                        if hasattr(order_result, "price")
                        else order_price
                    )

                    start_time = time.time()
                    while not self.stop_flag:
                        if self.primary_order_status == "CANCELED":
                            self.primary_order_status = None
                            (
                                best_bid,
                                best_ask,
                            ) = await self.primary_client.fetch_bbo_prices(
                                self.primary_contract_id
                            )
                            order_price = self.calculate_order_price(
                                side,
                                best_bid,
                                best_ask,
                                self.primary_tick_size,
                                self.primary_mode,
                            )
                            break

                        if self.primary_order_status == "FILLED":
                            return order_id

                        if self.primary_order_status in [
                            "OPEN",
                            "PENDING",
                            "PARTIALLY_FILLED",
                        ]:
                            await asyncio.sleep(0.1)  # Reduced from 0.5s for faster response

                            if time.time() - start_time > 10:
                                (
                                    best_bid,
                                    best_ask,
                                ) = await self.primary_client.fetch_bbo_prices(
                                    self.primary_contract_id
                                )
                                should_cancel = False

                                if (
                                    side == "buy"
                                    and actual_price < best_bid - self.primary_tick_size
                                ):
                                    should_cancel = True
                                elif (
                                    side == "sell"
                                    and actual_price > best_ask + self.primary_tick_size
                                ):
                                    should_cancel = True

                                if should_cancel:
                                    try:
                                        await self.primary_client.cancel_order(order_id)
                                    except Exception as e:
                                        self.logger.warning(
                                            f"Error canceling order: {e}"
                                        )
                                else:
                                    start_time = time.time()
                        else:
                            await asyncio.sleep(0.1)  # Reduced from 0.5s for faster response

                else:
                    self.logger.warning("Order placement failed, retrying...")
                    await asyncio.sleep(0.2)  # Reduced from 1s for faster retry

            except Exception as e:
                self.logger.error(f"Error placing PRIMARY order: {e}")
                await asyncio.sleep(0.2)  # Reduced from 1s for faster retry

        return None

    async def place_hedge_order(
        self, side: str, quantity: Decimal, reference_price: Decimal
    ) -> bool:
        self.hedge_order_filled = False
        order_type = "CLOSE" if side == "buy" else "OPEN"
        maker_timeout = 12  # Increased from 8 to allow WebSocket message delivery

        use_maker_mode = self.hedge_mode in [PriceMode.BBO_MINUS_1, PriceMode.BBO]

        max_retries = 4  # Increased retries for better reliability
        for attempt in range(1, max_retries + 1):
            try:
                best_bid, best_ask = await self.hedge_client.fetch_bbo_prices(
                    self.hedge_contract_id
                )

                # MARKET ORDER for CLOSE (like original ext.py)
                # CLOSE: Always use BBO for immediate fill
                if order_type == "CLOSE":
                    # CLOSE BUY (close SHORT): Buy at ASK (market order)
                    # CLOSE SELL (close LONG): Sell at BID (market order)
                    if side == "buy":
                        # Buy at ask + small buffer for guaranteed fill
                        order_price = best_ask + (self.hedge_tick_size * Decimal("2"))
                    else:
                        # Sell at bid - small buffer for guaranteed fill
                        order_price = best_bid - (self.hedge_tick_size * Decimal("2"))
                    order_mode = "MARKET"
                else:
                    # OPEN: Use PRIMARY fill price as reference
                    order_price = reference_price
                    order_mode = "TAKER_AGGRESSIVE"

                order_price = self.hedge_client.round_to_tick(order_price)

                # Log HEDGE order
                self.logger.info(
                    f"[{order_type}] [{self.hedge_exchange.upper()}] [{side.upper()}] "
                    f"{order_mode} @ {order_price} (ref: {reference_price}, BBO: {best_bid}/{best_ask})"
                )

                # Backpack/GRVT use string "buy"/"sell" directly
                order_side = side

                # Get position before placing order (REST API for reliability)
                pos_before = await self.hedge_client.get_account_positions()

                # Place HEDGE order using aggressive limit (match PRIMARY price)
                if hasattr(self.hedge_client, "place_aggressive_limit_order"):
                    order_info = await self.hedge_client.place_aggressive_limit_order(
                        contract_id=self.hedge_contract_id,
                        quantity=quantity,
                        price=order_price,
                        side=order_side,
                    )
                else:
                    # Use place_open_order for improved execution (cross spread for immediate fill)
                    order_info = await self.hedge_client.place_open_order(
                        contract_id=self.hedge_contract_id,
                        quantity=quantity,
                        direction=order_side,
                    )

                # Get order ID for tracking
                order_id = (
                    order_info.order_id if hasattr(order_info, "order_id") else None
                )

                # Wait for fill confirmation with REST API position check
                start_wait = time.time()
                reprice_count = 0
                order_filled = False

                while time.time() - start_wait < maker_timeout:
                    await asyncio.sleep(0.5)  # Increased from 0.1s to allow WebSocket message delivery

                    # Check via REST API position (more reliable than WebSocket)
                    pos_current = await self.hedge_client.get_account_positions()
                    position_change = abs(pos_current - pos_before)

                    if position_change >= quantity * Decimal("0.99"):
                        order_filled = True
                        break
                    new_bid, new_ask = await self.hedge_client.fetch_bbo_prices(
                        self.hedge_contract_id
                    )
                    # Update order_price to current BBO if price moved unfavorable
                    # Then place new order immediately (don't just break)
                    if side == "buy" and order_price < new_bid - self.hedge_tick_size:
                        order_price = new_ask
                        order_price = self.hedge_client.round_to_tick(order_price)
                        self.logger.info(
                            f"[{order_type}] Price moved, repricing to {order_price}"
                        )
                        # Place new order with updated price
                        if hasattr(self.hedge_client, "place_aggressive_limit_order"):
                            await self.hedge_client.place_aggressive_limit_order(
                                contract_id=self.hedge_contract_id,
                                quantity=quantity,
                                price=order_price,
                                side=order_side,
                            )
                        else:
                            await self.hedge_client.place_post_only_order(
                                contract_id=self.hedge_contract_id,
                                quantity=quantity,
                                price=order_price,
                                side=order_side,
                            )
                        reprice_count += 1
                        self.repricing_count += 1  # Track total repricing count
                        if reprice_count >= 5:  # Increased from 3 for better fill rates
                            self.logger.warning(
                                f"[{order_type}] Too many reprices, giving up"
                            )
                            break
                        continue
                    elif (
                        side == "sell" and order_price > new_ask + self.hedge_tick_size
                    ):
                        order_price = new_bid
                        order_price = self.hedge_client.round_to_tick(order_price)
                        self.logger.info(
                            f"[{order_type}] Price moved, repricing to {order_price}"
                        )
                        # Place new order with updated price
                        if hasattr(self.hedge_client, "place_aggressive_limit_order"):
                            await self.hedge_client.place_aggressive_limit_order(
                                contract_id=self.hedge_contract_id,
                                quantity=quantity,
                                price=order_price,
                                side=order_side,
                            )
                        else:
                            await self.hedge_client.place_post_only_order(
                                contract_id=self.hedge_contract_id,
                                quantity=quantity,
                                price=order_price,
                                side=order_side,
                            )
                        reprice_count += 1
                        self.repricing_count += 1  # Track total repricing count
                        if reprice_count >= 5:  # Increased from 3 for better fill rates
                            self.logger.warning(
                                f"[{order_type}] Too many reprices, giving up"
                            )
                            break
                        continue

                # Final check: Was order filled?
                if order_filled:
                    pos_after = pos_current
                    actual_fill_price = best_ask if side == "buy" else best_bid

                    self.logger.info(
                        f"[{order_type}] [{self.hedge_exchange.upper()}] [FILLED]: "
                        f"{quantity} @ ~{actual_fill_price} (pos: {pos_before} -> {pos_after})"
                    )

                    self.log_trade_to_csv(
                        exchange=self.hedge_exchange.upper(),
                        side=side,
                        price=str(actual_fill_price),
                        quantity=str(quantity),
                        order_type="hedge",
                        mode="aggressive_taker",
                    )

                    self.hedge_order_filled = True
                    self.order_execution_complete = True
                    self.last_hedge_fill_price = actual_fill_price
                    return True
                else:
                    # Order not confirmed by WebSocket within timeout
                    # Check REST API to confirm (may be filled but WS delayed)
                    self.logger.warning(
                        f"[{order_type}] Fill not confirmed by WebSocket (expected: {quantity}, actual: {position_change})"
                    )
                    self.logger.info(f"[{order_type}] Checking REST API for confirmation...")

                    try:
                        rest_position = await self.hedge_client.get_account_positions()
                        rest_position_change = abs(rest_position - pos_before)

                        if rest_position_change >= quantity * Decimal("0.9"):
                            # Confirmed filled by REST API
                            self.logger.info(
                                f"[{order_type}] Fill confirmed by REST API! (WS was delayed, actual: {rest_position_change})"
                            )
                            # Update local WebSocket position
                            if hasattr(self.hedge_client, '_local_position'):
                                self.hedge_client._local_position = rest_position

                            actual_fill_price = best_ask if side == "buy" else best_bid
                            self.hedge_order_filled = True
                            self.order_execution_complete = True
                            self.last_hedge_fill_price = actual_fill_price
                            return True
                        else:
                            # Still not filled after REST check - close at market
                            self.logger.warning(
                                f"[{order_type}] Still not filled after REST check (expected: {quantity}, actual: {rest_position_change})"
                            )
                            self.logger.warning(f"[{order_type}] Closing at market to prevent position mismatch...")

                            # Close opposite direction at market
                            close_side = "sell" if side == "buy" else "buy"
                            try:
                                close_result = await self.hedge_client.place_market_order(
                                    contract_id=self.hedge_contract_id,
                                    quantity=quantity,
                                    side=close_side
                                )
                                self.logger.info(
                                    f"[{order_type}] Market close order placed: {close_side.upper()} {quantity}"
                                )
                                # Consider it executed
                                self.hedge_order_filled = True
                                self.order_execution_complete = True
                                return True
                            except Exception as close_error:
                                self.logger.error(f"[{order_type}] Failed to close at market: {close_error}")
                                return False

                    except Exception as api_error:
                        self.logger.error(f"[{order_type}] REST API check failed: {api_error}")
                        return False

            except Exception as e:
                self.logger.error(
                    f"Error placing HEDGE order (attempt {attempt}/{max_retries}): {e}"
                )
                if attempt < max_retries:
                    self.logger.info(f"Retrying hedge order in 1 second...")
                    await asyncio.sleep(1)
                else:
                    self.logger.error(f"All {max_retries} hedge attempts failed!")
                    self.logger.error(traceback.format_exc())

        self.logger.error(
            "[EMERGENCY] Hedge order failed after all retries, closing primary position!"
        )
        await self.emergency_close_primary(quantity, side)
        return False

    async def force_close_all_positions(self):
        """Force close all positions with improved verification and retry logic.

        Key improvements:
        - 10 second max wait for fill confirmation
        - Absolute threshold (0.001) instead of percentage
        - WebSocket + REST parallel confirmation
        - Max 3 retry attempts
        - Better error handling and logging
        """
        try:
            self.logger.info("[FORCE_CLOSE] Starting forced position cleanup with improved logic...")

            # Check both exchanges using REST API for accurate positions
            for exchange_name, client in [
                ("PRIMARY", self.primary_client),
                ("HEDGE", self.hedge_client),
            ]:
                if client is None:
                    continue

                # 1. Get REST API position (authoritative)
                try:
                    rest_pos = await client.get_account_positions()
                except Exception as e:
                    self.logger.error(f"[FORCE_CLOSE] Failed to get {exchange_name} position: {e}")
                    continue

                if abs(rest_pos) < Decimal("0.001"):
                    self.logger.info(f"[FORCE_CLOSE] {exchange_name} already flat: {rest_pos}")
                    continue

                self.logger.warning(
                    f"[FORCE_CLOSE] {exchange_name} has residual position: {rest_pos}, forcing close"
                )

                # 2. Determine close side and quantity
                close_side = "sell" if rest_pos > 0 else "buy"
                close_qty = abs(rest_pos)

                # 3. Get BBO for aggressive pricing
                try:
                    best_bid, best_ask = await client.fetch_bbo_prices(client.config.contract_id)

                    # Use aggressive pricing for immediate fill
                    if close_side == "buy":
                        # Cross spread: buy at ASK (aggressive)
                        close_price = best_ask  # Cross immediately
                    else:
                        # Cross spread: sell at BID (aggressive)
                        close_price = best_bid  # Cross immediately

                    self.logger.warning(
                        f"[FORCE_CLOSE] {exchange_name} {close_side.upper()} {close_qty} @ market (crossing spread)"
                    )

                    # 4. Place close order
                    if hasattr(client, "place_market_order"):
                        # GRVT: Use market order for immediate fill
                        await client.place_market_order(
                            contract_id=client.config.contract_id,
                            quantity=close_qty,
                            side=close_side,
                        )
                        self.logger.info(f"[FORCE_CLOSE] Market order placed for {exchange_name}")
                    else:
                        # Paradex: Use aggressive limit order (cross spread)
                        await client.place_post_only_order(
                            contract_id=client.config.contract_id,
                            quantity=close_qty,
                            price=close_price,
                            side=close_side,
                        )
                        self.logger.info(f"[FORCE_CLOSE] Aggressive limit order placed for {exchange_name}")

                    # 5. Wait for fill with REST API PRIMARY confirmation
                    filled = False
                    max_wait = 10  # 10 seconds max wait

                    for i in range(max_wait * 10):  # 0.1 second intervals
                        await asyncio.sleep(0.1)

                        # REST API confirmation every 0.5 second (every 5 iterations) - PRIMARY CHECK
                        # REST API is authoritative, WebSocket is supplementary only
                        if i % 5 == 0:
                            rest_check = await client.get_account_positions()
                            if abs(rest_check) < Decimal("0.001"):
                                self.logger.info(f"[FORCE_CLOSE] {exchange_name} filled (REST confirmed - authoritative)")
                                filled = True
                                break

                        # WebSocket confirmation SUPPLEMENTARY ONLY (checked after REST)
                        # WebSocket can show false positives, so we only use it as a hint
                        if hasattr(client, 'get_ws_position'):
                            ws_pos = client.get_ws_position()
                            if abs(ws_pos) < Decimal("0.001"):
                                # WS shows 0, but we still need REST confirmation
                                # Just log it and continue to next REST check
                                self.logger.debug(f"[FORCE_CLOSE] {exchange_name} WS shows 0, waiting for REST confirmation...")

                    # 6. If not filled, retry up to 3 times
                    if not filled:
                        remaining = await client.get_account_positions()

                        # Use ABSOLUTE threshold (0.001) instead of percentage
                        if abs(remaining) > Decimal("0.001"):
                            self.logger.warning(
                                f"[FORCE_CLOSE] {exchange_name} not filled after {max_wait}s. "
                                f"Remaining: {remaining}. Retrying (max 3 attempts)..."
                            )

                            # Retry loop (max 3 attempts)
                            for retry in range(3):
                                self.logger.warning(
                                    f"[FORCE_CLOSE] Retry attempt {retry + 1}/3 for {exchange_name}..."
                                )

                                # Re-check position (may have been filled during wait)
                                current_pos = await client.get_account_positions()
                                if abs(current_pos) < Decimal("0.001"):
                                    self.logger.info(
                                        f"[FORCE_CLOSE] {exchange_name} filled during wait before retry {retry + 1}"
                                    )
                                    filled = True
                                    break

                                # Place retry order
                                retry_qty = abs(current_pos)

                                if hasattr(client, "place_market_order"):
                                    await client.place_market_order(
                                        contract_id=client.config.contract_id,
                                        quantity=retry_qty,
                                        side=close_side,
                                    )
                                else:
                                    # Re-fetch BBO for retry
                                    best_bid, best_ask = await client.fetch_bbo_prices(client.config.contract_id)
                                    retry_price = best_ask if close_side == "buy" else best_bid
                                    await client.place_post_only_order(
                                        contract_id=client.config.contract_id,
                                        quantity=retry_qty,
                                        price=retry_price,
                                        side=close_side,
                                    )

                                # Wait for retry fill with REST API PRIMARY confirmation
                                for j in range(max_wait * 10):
                                    await asyncio.sleep(0.1)

                                    # REST API confirmation every 0.5 second (every 5 iterations) - PRIMARY
                                    if j % 5 == 0:
                                        rest_check = await client.get_account_positions()
                                        if abs(rest_check) < Decimal("0.001"):
                                            self.logger.info(
                                                f"[FORCE_CLOSE] {exchange_name} retry {retry + 1} filled (REST - authoritative)"
                                            )
                                            filled = True
                                            break

                                    # WebSocket check SUPPLEMENTARY ONLY
                                    if hasattr(client, 'get_ws_position'):
                                        ws_pos = client.get_ws_position()
                                        if abs(ws_pos) < Decimal("0.001"):
                                            self.logger.debug(
                                                f"[FORCE_CLOSE] {exchange_name} retry {retry + 1} WS shows 0, waiting for REST..."
                                            )

                                if filled:
                                    break

                            # Final check after all retries
                            final_remaining = await client.get_account_positions()
                            if abs(final_remaining) > Decimal("0.001"):
                                self.logger.error(
                                    f"[FORCE_CLOSE] {exchange_name} FAILED to close after 3 retries! "
                                    f"Remaining: {final_remaining}. Manual intervention required."
                                )
                            else:
                                self.logger.info(
                                    f"[FORCE_CLOSE] {exchange_name} successfully closed after retries"
                                )

                except Exception as inner_e:
                    self.logger.error(f"[FORCE_CLOSE] Error closing {exchange_name}: {inner_e}")
                    import traceback
                    self.logger.error(f"[FORCE_CLOSE] Traceback: {traceback.format_exc()}")

            # 7. Final verification of all positions
            await asyncio.sleep(1)
            final_primary = await self.primary_client.get_account_positions()
            final_hedge = await self.hedge_client.get_account_positions()
            final_net = final_primary + final_hedge

            self.logger.info(
                f"[FORCE_CLOSE] Final positions - PRIMARY: {final_primary}, HEDGE: {final_hedge}, Net: {final_net}"
            )

            if abs(final_net) > self.order_quantity * Decimal("0.5"):
                self.logger.error(
                    f"[FORCE_CLOSE] WARNING: Net delta still significant: {final_net}. "
                    f"Manual position check recommended."
                )
            else:
                self.logger.info("[FORCE_CLOSE] All positions successfully closed")

        except Exception as e:
            self.logger.error(f"[FORCE_CLOSE] Error: {e}")

    async def emergency_close_primary(self, quantity: Decimal, failed_hedge_side: str):
        close_side = failed_hedge_side

        self.logger.warning(
            f"[EMERGENCY] Closing PRIMARY position: {close_side.upper()} {quantity}"
        )

        max_close_attempts = 3
        for attempt in range(max_close_attempts):
            try:
                # Use market order for emergency close (more reliable)
                # Backpack/GRVT use string "buy"/"sell" directly
                order_side = close_side

                # Try to use market order if available
                if hasattr(self.primary_client, "place_market_order"):
                    await self.primary_client.place_market_order(
                        contract_id=self.primary_contract_id,
                        quantity=quantity,
                        side=order_side,
                    )
                    self.logger.warning(
                        f"[EMERGENCY] MARKET order placed: {close_side.upper()} {quantity}"
                    )
                else:
                    # Fallback: aggressive limit order (small buffer)
                    best_bid, best_ask = await self.primary_client.fetch_bbo_prices(
                        self.primary_contract_id
                    )

                    if close_side == "buy":
                        price = best_ask + (self.primary_tick_size * Decimal("3"))
                    else:
                        price = best_bid - (self.primary_tick_size * Decimal("3"))

                    # Round to tick size
                    price = self.primary_client.round_to_tick(price)

                    await self.primary_client.place_post_only_order(
                        contract_id=self.primary_contract_id,
                        quantity=quantity,
                        price=price,
                        side=order_side,
                    )

                    self.logger.warning(
                        f"[EMERGENCY] Aggressive limit order placed: {close_side.upper()} {quantity} @ {price}"
                    )

                # Wait for order to process
                await asyncio.sleep(2)

                # Verify position was closed
                primary_pos = await self.primary_client.get_account_positions()

                # Check if position was reduced (allow for some tolerance)
                position_ok = abs(primary_pos) < quantity * Decimal("0.1")

                if position_ok:
                    self.logger.info(
                        f"[EMERGENCY] Primary position closed successfully: {primary_pos}"
                    )

                    # Update local tracking
                    self.local_primary_position = primary_pos
                    self.primary_position = primary_pos

                    # Get approximate fill price for logging
                    best_bid, best_ask = await self.primary_client.fetch_bbo_prices(
                        self.primary_contract_id
                    )
                    approx_price = best_ask if close_side == "buy" else best_bid

                    self.log_trade_to_csv(
                        exchange=self.primary_exchange.upper(),
                        side=close_side,
                        price=str(approx_price),
                        quantity=str(quantity),
                        order_type="emergency_close",
                        mode="market",
                    )
                    return  # Success
                else:
                    self.logger.warning(
                        f"[EMERGENCY] Close attempt {attempt+1}/{max_close_attempts} failed. Position: {primary_pos}"
                    )
                    if attempt < max_close_attempts - 1:
                        self.logger.info("[EMERGENCY] Retrying in 2 seconds...")
                        await asyncio.sleep(2)

            except Exception as e:
                self.logger.error(
                    f"[EMERGENCY] Close attempt {attempt+1} failed: {e}"
                )
                if attempt < max_close_attempts - 1:
                    await asyncio.sleep(2)

        # All attempts failed
        self.logger.error("[EMERGENCY] Failed to close primary position after all attempts!")
        self.logger.error(traceback.format_exc())
        self.stop_flag = True

    def _reset_current_cycle_metrics(self):
        """Reset current cycle metrics at start of new cycle."""
        self.current_cycle_start_time = time.time()
        self.repricing_count = 0
        self.current_primary_entry_price = None
        self.current_hedge_entry_price = None
        self.current_primary_entry_time = None
        self.current_hedge_entry_time = None
        self.current_primary_exit_price = None
        self.current_hedge_exit_price = None
        self.current_primary_exit_time = None
        self.current_hedge_exit_time = None
        self.current_order_to_fill_primary = 0
        self.current_order_to_fill_hedge = 0
        self.current_websocket_latency = 0
        self.current_rest_latency = 0
        self.current_reconciliation_time = 0

    def _create_trade_metrics(self, iteration: int, direction: str) -> TradeMetrics:
        """Create TradeMetrics object from current cycle data."""
        cycle_time = time.time() - self.current_cycle_start_time if self.current_cycle_start_time else 0

        return TradeMetrics(
            iteration=iteration,
            direction=direction,
            primary_entry_price=self.current_primary_entry_price or Decimal("0"),
            hedge_entry_price=self.current_hedge_entry_price or Decimal("0"),
            primary_entry_time=self.current_primary_entry_time or 0,
            hedge_entry_time=self.current_hedge_entry_time or 0,
            primary_exit_price=self.current_primary_exit_price or Decimal("0"),
            hedge_exit_price=self.current_hedge_exit_price or Decimal("0"),
            primary_exit_time=self.current_primary_exit_time or 0,
            hedge_exit_time=self.current_hedge_exit_time or 0,
            order_to_fill_primary=self.current_order_to_fill_primary,
            order_to_fill_hedge=self.current_order_to_fill_hedge,
            websocket_latency=self.current_websocket_latency,
            rest_latency=self.current_rest_latency,
            reconciliation_time=self.current_reconciliation_time,
            repricing_count=self.repricing_count,
            total_cycle_time=cycle_time,
        )

    async def execute_dn_cycle(
        self, direction: str
    ) -> Tuple[bool, Optional[Decimal], Optional[Decimal]]:
        self.order_execution_complete = False
        self.waiting_for_hedge_fill = False

        # Track primary order timing
        primary_order_start = time.time()

        order_id = await self.place_primary_order(direction, self.order_quantity)

        if order_id is None:
            return False, None, None

        # Track primary order fill time
        self.current_order_to_fill_primary = (time.time() - primary_order_start) * 1000  # ms

        start_time = time.time()
        primary_fill_price = None
        hedge_fill_price = None

        while not self.order_execution_complete and not self.stop_flag:
            if self.waiting_for_hedge_fill:
                primary_fill_price = self.current_hedge_price

                # Track hedge order timing
                hedge_order_start = time.time()

                success = await self.place_hedge_order(
                    self.current_hedge_side,
                    self.current_hedge_quantity,
                    self.current_hedge_price,
                )

                # Track hedge order fill time
                self.current_order_to_fill_hedge = (time.time() - hedge_order_start) * 1000  # ms

                if success and hasattr(self, "last_hedge_fill_price"):
                    hedge_fill_price = self.last_hedge_fill_price
                break

            await asyncio.sleep(0.01)

            if time.time() - start_time > 180:
                self.logger.error("Timeout waiting for trade completion")
                return False, None, None

        # Store entry/exit prices based on direction
        if direction == "buy":
            # Building long position
            if self.current_primary_entry_price is None:
                self.current_primary_entry_price = primary_fill_price or Decimal("0")
                self.current_primary_entry_time = time.time()
            if self.current_hedge_entry_price is None:
                self.current_hedge_entry_price = hedge_fill_price or Decimal("0")
                self.current_hedge_entry_time = time.time()
        else:
            # Unwinding (selling)
            self.current_primary_exit_price = primary_fill_price or Decimal("0")
            self.current_primary_exit_time = time.time()
            self.current_hedge_exit_price = hedge_fill_price or Decimal("0")
            self.current_hedge_exit_time = time.time()

        return True, primary_fill_price, hedge_fill_price

    async def trading_loop(self):
        self.logger.info(f"{'=' * 60}")
        self.logger.info("DN Hedge Bot Starting (ALTERNATIVE STRATEGY)")
        self.logger.info(
            f"PRIMARY: {self.primary_exchange.upper()} ({self.primary_mode.value}) | "
            f"HEDGE: {self.hedge_exchange.upper()} ({self.hedge_mode.value})"
        )
        self.logger.info(
            f"Ticker: {self.ticker} | Quantity: {self.order_quantity} | Iterations: {self.iterations}"
        )
        self.logger.info(f"{'=' * 60}")

        try:
            await self.initialize_clients()
            await self.connect_websockets()
        except Exception as e:
            self.logger.error(f"Failed to initialize: {e}")
            return

        await asyncio.sleep(5)  # Increased from 3 for initial WebSocket stabilization

        api_primary, api_hedge = await self.get_positions(force_api=True)
        self.local_primary_position = api_primary
        self.local_hedge_position = api_hedge
        self.primary_position = api_primary
        self.hedge_position = api_hedge
        self.logger.info(
            f"[INIT] Positions - PRIMARY: {self.primary_position}, HEDGE: {self.hedge_position}"
        )

        # Check for residual positions and auto-close if needed
        net_delta = api_primary + api_hedge
        if abs(net_delta) > self.order_quantity:
            self.logger.warning(
                f"[INIT] Residual positions detected! Primary: {api_primary}, Hedge: {api_hedge}, Net: {net_delta}"
            )
            self.logger.warning("[INIT] Auto-closing residual positions...")

            try:
                await self.force_close_all_positions()

                # Wait and recheck (reduced from 5s for faster startup)
                await asyncio.sleep(3)
                api_primary, api_hedge = await self.get_positions(force_api=True)
                net_delta = api_primary + api_hedge

                if abs(net_delta) > self.order_quantity * Decimal("0.5"):
                    self.logger.error(
                        f"[INIT] Failed to close residual positions! Net: {net_delta}. Please manually close positions."
                    )
                    self.logger.error("[INIT] Bot cannot start safely. Exiting...")
                    return
                else:
                    self.logger.info(f"[INIT] Residual positions closed successfully. Net: {net_delta}")
                    # Update local tracking
                    self.local_primary_position = api_primary
                    self.local_hedge_position = api_hedge
                    self.primary_position = api_primary
                    self.hedge_position = api_hedge

            except Exception as e:
                self.logger.error(f"[INIT] Error during residual position cleanup: {e}")
                self.logger.error("[INIT] Bot cannot start safely. Exiting...")
                return

        cycle_count = 0

        for iteration in range(1, self.iterations + 1):
            if self.stop_flag:
                break

            self.logger.info(f"\n{'=' * 40}")
            self.logger.info(f"Iteration {iteration}/{self.iterations}")
            self.logger.info(f"{'=' * 40}")

            # Reset metrics for new cycle
            self._reset_current_cycle_metrics()

            await self.reconcile_positions()

            # Direction determination: odd=buy first, even=sell first
            build_direction = "buy" if iteration % 2 == 1 else "sell"
            unwind_direction = "sell" if build_direction == "buy" else "buy"

            self.logger.info(
                f"[DIRECTION] BUILD: {build_direction.upper()}, UNWIND: {unwind_direction.upper()}"
            )

            # ===== BUILD Phase: max_position =====
            while (
                abs(self.primary_client.get_ws_position()) < self.max_position
                and not self.stop_flag
            ):
                cycle_count += 1

                if cycle_count % self.reconcile_interval == 0:
                    await self.reconcile_positions()
                    # Sync WebSocket positions with REST API periodically
                    if hasattr(self.hedge_client, "sync_ws_position_if_needed"):
                        await self.hedge_client.sync_ws_position_if_needed(cycle_count)
                    if hasattr(self.primary_client, "sync_ws_position_if_needed"):
                        await self.primary_client.sync_ws_position_if_needed(cycle_count)

                # Use WebSocket positions for both exchanges (real-time tracking)
                self.primary_position = self.primary_client.get_ws_position()
                self.hedge_position = self.hedge_client.get_ws_position()
                net_delta = self.primary_position + self.hedge_position

                self.logger.info(
                    f"[BUILD] PRIMARY(WS): {self.primary_position} | HEDGE(WS): {self.hedge_position} | Net: {net_delta}"
                )

                # Position imbalance threshold during operation: 5x for tolerance
                if abs(net_delta) > self.order_quantity * 5:
                    self.logger.error(f"Position imbalance too large: {net_delta}")
                    self.stop_flag = True
                    break

                if not await self.check_arbitrage_opportunity(build_direction):
                    await asyncio.sleep(0.1)  # Reduced from 1s for faster retry
                    continue

                success, primary_price, hedge_price = await self.execute_dn_cycle(build_direction)
                if success and primary_price and hedge_price:
                    hedge_side = "sell" if build_direction == "buy" else "buy"
                    self.print_trade_summary(
                        cycle_count,
                        build_direction,
                        primary_price,
                        hedge_side,
                        hedge_price,
                        self.order_quantity,
                    )
                if not success:
                    await asyncio.sleep(1)  # Reduced from 5s for faster recovery

            if self.sleep_time > 0:
                self.logger.info(f"Sleeping {self.sleep_time}s...")
                await asyncio.sleep(self.sleep_time)

            # ===== UNWIND Phase: 0 =====
            while (
                abs(self.primary_client.get_ws_position()) > 0
                and not self.stop_flag
            ):
                cycle_count += 1

                if cycle_count % self.reconcile_interval == 0:
                    await self.reconcile_positions()
                    # Sync WebSocket positions with REST API periodically
                    if hasattr(self.hedge_client, "sync_ws_position_if_needed"):
                        await self.hedge_client.sync_ws_position_if_needed(cycle_count)
                    if hasattr(self.primary_client, "sync_ws_position_if_needed"):
                        await self.primary_client.sync_ws_position_if_needed(cycle_count)

                # Use WebSocket positions for both exchanges (real-time tracking)
                self.primary_position = self.primary_client.get_ws_position()
                self.hedge_position = self.hedge_client.get_ws_position()
                net_delta = self.primary_position + self.hedge_position

                self.logger.info(
                    f"[UNWIND] PRIMARY(WS): {self.primary_position} | HEDGE(WS): {self.hedge_position} | Net: {net_delta}"
                )

                # Position imbalance threshold during operation: 5x for tolerance
                if abs(net_delta) > self.order_quantity * 5:
                    self.logger.error(f"Position imbalance too large: {net_delta}")
                    self.stop_flag = True
                    break

                if not await self.check_arbitrage_opportunity(unwind_direction):
                    await asyncio.sleep(0.1)  # Reduced from 1s for faster retry
                    continue

                success, primary_price, hedge_price = await self.execute_dn_cycle(
                    unwind_direction
                )
                if success and primary_price and hedge_price:
                    hedge_side = "sell" if unwind_direction == "buy" else "buy"
                    self.print_trade_summary(
                        cycle_count,
                        unwind_direction,
                        primary_price,
                        hedge_side,
                        hedge_price,
                        self.order_quantity,
                    )
                if not success:
                    await asyncio.sleep(1)  # Reduced from 5s for faster recovery

            # Create and store trade metrics after completing BUILD + UNWIND cycle
            direction_label = "BUY_FIRST" if iteration % 2 == 1 else "SELL_FIRST"
            metrics = self._create_trade_metrics(iteration, direction_label)
            self.trade_metrics_list.append(metrics)

            self.logger.info(
                f"[METRICS] Cycle {iteration} complete - "
                f"Entry: P={metrics.primary_entry_price} H={metrics.hedge_entry_price}, "
                f"Exit: P={metrics.primary_exit_price} H={metrics.hedge_exit_price}, "
                f"Time: {metrics.total_cycle_time:.2f}s"
            )

        final_primary, final_hedge = await self.get_positions(force_api=True)
        avg_pnl_bps = (
            (self.total_gross_pnl / self.total_volume) * Decimal("10000")
            if self.total_volume > 0
            else Decimal("0")
        )

        self.logger.info(f"\n{'=' * 60}")
        self.logger.info("TRADING COMPLETE - FINAL SUMMARY")
        self.logger.info(f"{'=' * 60}")
        self.logger.info(f"  Completed Cycles: {self.completed_cycles}")
        self.logger.info(f"  Total Volume: ${self.total_volume:.2f}")
        self.logger.info(f"  Total Gross PnL: ${self.total_gross_pnl:.4f}")
        self.logger.info(f"  Average Edge: {avg_pnl_bps:+.2f} bps")
        self.logger.info(f"{'-' * 60}")
        self.logger.info(
            f"  Final Positions - BACKPACK: {final_primary}, GRVT: {final_hedge}"
        )
        self.logger.info(f"  Net Delta: {final_primary + final_hedge}")
        self.logger.info(f"{'=' * 60}")
        self.logger.info(f"  Completed Cycles: {self.completed_cycles}")
        self.logger.info(f"  Total Volume: ${self.total_volume:.2f}")
        self.logger.info(f"  Total Gross PnL: ${self.total_gross_pnl:.4f}")
        self.logger.info(f"  Average Edge: {avg_pnl_bps:+.2f} bps")
        self.logger.info(f"{'─' * 60}")
        self.logger.info(
            f"  Final Positions - BACKPACK: {final_primary}, GRVT: {final_hedge}"
        )
        self.logger.info(f"  Net Delta: {final_primary + final_hedge}")
        self.logger.info(f"{'=' * 60}")

        # Auto-cleanup residual positions at shutdown
        net_delta = final_primary + final_hedge
        if abs(net_delta) > self.order_quantity * Decimal("0.5"):
            self.logger.warning(f"[SHUTDOWN] Residual positions detected! Net: {net_delta}")
            self.logger.warning("[SHUTDOWN] Auto-closing residual positions...")
            await self.force_close_all_positions()

            # Verify cleanup succeeded
            await asyncio.sleep(3)
            final_primary, final_hedge = await self.get_positions(force_api=True)
            net_delta = final_primary + final_hedge

            if abs(net_delta) > self.order_quantity * Decimal("0.5"):
                self.logger.error(f"[SHUTDOWN] Failed to close residual positions! Net: {net_delta}")
            else:
                self.logger.info(f"[SHUTDOWN] Residual positions closed successfully. Net: {net_delta}")
        else:
            self.logger.info("[SHUTDOWN] No residual positions. Clean shutdown.")

        # Export trade metrics at shutdown
        self.logger.info("[SHUTDOWN] Exporting trade metrics...")
        self.export_trade_metrics()

    async def run(self):
        self.setup_signal_handlers()

        try:
            await self.trading_loop()
        except KeyboardInterrupt:
            self.logger.info("\nReceived interrupt signal...")
        finally:
            self.logger.info("Cleaning up...")
            await self.cleanup_connections()
            self.shutdown()


def parse_arguments():
    import argparse

    parser = argparse.ArgumentParser(
        description="Delta Neutral Hedge Bot: Backpack + GRVT",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Test 1: PRIMARY=BBO-1tick, HEDGE=market (default)
    python DN_alternate_backpack_grvt.py --ticker SOL --size 1 --iter 10

    # Test 2: PRIMARY=BBO, HEDGE=market
    python DN_alternate_backpack_grvt.py --ticker SOL --size 1 --iter 10 --primary-mode bbo

    # Test 3: PRIMARY=BBO-1tick, HEDGE=BBO-1tick
    python DN_alternate_backpack_grvt.py --ticker SOL --size 1 --iter 10 --hedge-mode bbo_minus_1

    # Test 4: PRIMARY=BBO, HEDGE=BBO
    python DN_alternate_backpack_grvt.py --ticker SOL --size 1 --iter 10 --primary-mode bbo --hedge-mode bbo
        """,
    )

    parser.add_argument(
        "--ticker", type=str, default="SOL", help="Ticker symbol (default: SOL)"
    )
    parser.add_argument(
        "--size", type=str, required=True, help="Order quantity per trade"
    )
    parser.add_argument(
        "--iter", type=int, required=True, help="Number of trading iterations"
    )
    parser.add_argument(
        "--fill-timeout",
        type=int,
        default=5,
        help="Timeout for order fills in seconds (default: 5)",
    )
    parser.add_argument(
        "--sleep",
        type=int,
        default=0,
        help="Sleep time between iterations in seconds (default: 0)",
    )
    parser.add_argument(
        "--max-position",
        type=str,
        default="0",
        help="Maximum position size (default: same as --size)",
    )
    parser.add_argument(
        "--primary",
        type=str,
        default="backpack",
        choices=["backpack", "grvt"],
        help="Primary exchange for POST_ONLY orders (default: backpack)",
    )
    parser.add_argument(
        "--hedge",
        type=str,
        default="grvt",
        choices=["backpack", "grvt"],
        help="Hedge exchange for market orders (default: grvt)",
    )
    parser.add_argument(
        "--primary-mode",
        type=str,
        default="bbo",
        choices=["bbo_minus_1", "bbo", "aggressive"],
        help="Primary order price mode (default: bbo). Use 'bbo' for volatile markets, 'aggressive' for immediate fills",
    )
    parser.add_argument(
        "--hedge-mode",
        type=str,
        default="market",
        choices=["market", "bbo_minus_1", "bbo_plus_1", "bbo", "aggressive"],
        help="Hedge order price mode (default: market). aggressive: BUY@ask, SELL@bid for instant fill",
    )
    parser.add_argument(
        "--env-file", type=str, default=".env", help=".env file path (default: .env)"
    )
    parser.add_argument(
        "--min-spread",
        type=str,
        default="0",
        help="Minimum spread in bps to enter trade (default: 0 = disabled)",
    )
    return parser.parse_args()


async def main():
    from pathlib import Path
    import dotenv

    args = parse_arguments()

    env_path = Path(args.env_file)
    if not env_path.exists():
        print(f"Error: .env file not found: {env_path.resolve()}")
        sys.exit(1)
    dotenv.load_dotenv(args.env_file)

    if args.primary == args.hedge:
        print("Error: PRIMARY and HEDGE exchanges must be different")
        sys.exit(1)

    primary_mode = PriceMode(args.primary_mode)
    hedge_mode = PriceMode(args.hedge_mode)

    bot = DNHedgeBot(
        ticker=args.ticker.upper(),
        order_quantity=Decimal(args.size),
        fill_timeout=args.fill_timeout,
        iterations=args.iter,
        sleep_time=args.sleep,
        max_position=Decimal(args.max_position),
        primary_exchange=args.primary,
        hedge_exchange=args.hedge,
        primary_mode=primary_mode,
        hedge_mode=hedge_mode,
        min_spread_bps=Decimal(args.min_spread),
    )

    await bot.run()


if __name__ == "__main__":
    asyncio.run(main())
