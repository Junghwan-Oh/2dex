"""
GRVT exchange client implementation.
"""

import os
import asyncio
import time
from decimal import Decimal
from typing import Dict, Any, List, Optional, Tuple
from pysdk.grvt_ccxt import GrvtCcxt
from pysdk.grvt_ccxt_ws import GrvtCcxtWS
from pysdk.grvt_ccxt_env import GrvtEnv, GrvtWSEndpointType

from .base import BaseExchangeClient, OrderResult, OrderInfo, query_retry
from helpers.logger import TradingLogger


class GrvtClient(BaseExchangeClient):
    """GRVT exchange client implementation."""

    def __init__(self, config: Dict[str, Any]):
        """Initialize GRVT client."""
        super().__init__(config)

        # GRVT credentials from environment
        self.trading_account_id = os.getenv("GRVT_TRADING_ACCOUNT_ID")
        self.private_key = os.getenv("GRVT_PRIVATE_KEY")
        self.api_key = os.getenv("GRVT_API_KEY")
        self.environment = os.getenv("GRVT_ENVIRONMENT", "prod")

        if not self.trading_account_id or not self.private_key or not self.api_key:
            raise ValueError(
                "GRVT_TRADING_ACCOUNT_ID, GRVT_PRIVATE_KEY, and GRVT_API_KEY must be set in environment variables"
            )

        # Convert environment string to proper enum
        env_map = {
            "prod": GrvtEnv.PROD,
            "testnet": GrvtEnv.TESTNET,
            "staging": GrvtEnv.STAGING,
            "dev": GrvtEnv.DEV,
        }
        self.env = env_map.get(self.environment.lower(), GrvtEnv.PROD)

        # Initialize logger
        self.logger = TradingLogger(
            exchange="grvt", ticker=self.config.ticker, log_to_console=True
        )

        # Initialize GRVT clients
        self._initialize_grvt_clients()

        self._order_update_handler = None
        self._ws_client = None
        self._order_update_callback = None
        self._local_position = Decimal("0")  # Local position tracking via WebSocket
        self._last_sync_time = 0  # Last REST API position sync time
        self._sync_interval = 1  # Sync with REST API every cycle (reduced from 3 for better accuracy)

    def _initialize_grvt_clients(self) -> None:
        """Initialize the GRVT REST and WebSocket clients."""
        try:
            # Parameters for GRVT SDK
            parameters = {
                "trading_account_id": self.trading_account_id,
                "private_key": self.private_key,
                "api_key": self.api_key,
            }

            # Initialize REST client
            self.rest_client = GrvtCcxt(env=self.env, parameters=parameters)

        except Exception as e:
            raise ValueError(f"Failed to initialize GRVT client: {e}")

    def _validate_config(self) -> None:
        """Validate GRVT configuration."""
        required_env_vars = [
            "GRVT_TRADING_ACCOUNT_ID",
            "GRVT_PRIVATE_KEY",
            "GRVT_API_KEY",
        ]
        missing_vars = [var for var in required_env_vars if not os.getenv(var)]
        if missing_vars:
            raise ValueError(f"Missing required environment variables: {missing_vars}")

    async def connect(self) -> None:
        """Connect to GRVT WebSocket."""
        try:
            # Initialize WebSocket client - match the working test implementation
            loop = asyncio.get_running_loop()

            # Import logger from pysdk like in the test file
            from pysdk.grvt_ccxt_logging_selector import logger

            # Parameters for GRVT SDK - match test file structure
            parameters = {
                "api_key": self.api_key,
                "trading_account_id": self.trading_account_id,
                "api_ws_version": "v1",
                "private_key": self.private_key,
            }

            self._ws_client = GrvtCcxtWS(
                env=self.env,
                loop=loop,
                logger=logger,  # Add logger parameter like in test file
                parameters=parameters,
            )

            # Initialize and connect
            await self._ws_client.initialize()
            await asyncio.sleep(2)  # Wait for connection to establish

            # If an order update callback was set before connect, subscribe now
            if self._order_update_callback is not None:
                asyncio.create_task(
                    self._subscribe_to_orders(self._order_update_callback)
                )
                self.logger.log(
                    f"Deferred subscription started for {self.config.contract_id}",
                    "INFO",
                )

        except Exception as e:
            self.logger.log(f"Error connecting to GRVT WebSocket: {e}", "ERROR")
            raise

    async def disconnect(self) -> None:
        """Disconnect from GRVT."""
        try:
            if self._ws_client:
                await self._ws_client.__aexit__()
        except Exception as e:
            self.logger.log(f"Error during GRVT disconnect: {e}", "ERROR")

    def get_ws_position(self) -> Decimal:
        """Get position from local WebSocket tracking.

        Improved: Periodically sync with REST API to ensure accuracy.
        Returns the locally tracked position, synced with REST API periodically.
        """
        # Note: This is a synchronous method, so we can't do async operations here.
        # The actual sync should be done from the main trading loop.
        return self._local_position

    async def sync_ws_position_if_needed(self, cycle_count: int) -> None:
        """Sync WebSocket position with REST API if needed.

        Args:
            cycle_count: Current cycle count for determining sync interval
        """
        # Sync every N cycles to ensure position accuracy
        if cycle_count > 0 and cycle_count % self._sync_interval == 0:
            try:
                rest_position = await self.get_account_positions()
                position_diff = abs(self._local_position - rest_position)

                if position_diff > Decimal("0.001"):  # More than 0.001 difference
                    self.logger.log(
                        f"[WS_SYNC] Syncing position: WS={self._local_position}, REST={rest_position}, diff={position_diff}",
                        "WARNING",
                    )
                    self._local_position = rest_position
            except Exception as e:
                self.logger.log(
                    f"[WS_SYNC] Failed to sync position: {e}",
                    "ERROR",
                )

    def get_exchange_name(self) -> str:
        """Get the exchange name."""
        return "grvt"

    def setup_order_update_handler(self, handler) -> None:
        """Setup order update handler for WebSocket."""
        self._order_update_handler = handler

        async def order_update_callback(message: Dict[str, Any]):
            """Handle order updates from WebSocket - match working test implementation."""
            # Log raw message for debugging
            self.logger.log(f"Received WebSocket message: {message}", "INFO")
            self.logger.log(
                "**************************************************", "INFO"
            )
            try:
                # Parse the message structure - match the working test implementation exactly
                if "feed" in message:
                    data = message.get("feed", {})
                    leg = data.get("legs", [])[0] if data.get("legs") else None

                    if isinstance(data, dict) and leg:
                        contract_id = leg.get("instrument", "")
                        if contract_id != self.config.contract_id:
                            self.logger.log(f"Skipping - contract mismatch: {contract_id} != {self.config.contract_id}", "INFO")
                            return

                        order_state = data.get("state", {})
                        # Extract order data using the exact structure from test
                        order_id = data.get("order_id", "")
                        status = order_state.get("status", "")
                        side = "buy" if leg.get("is_buying_asset") else "sell"
                        size = leg.get("size", "0")
                        price = leg.get("limit_price", "0")
                        filled_size = (
                            order_state.get("traded_size")[0]
                            if order_state.get("traded_size")
                            else "0"
                        )

                        self.logger.log(f"Processing order update: {order_id} status={status} side={side} filled={filled_size}", "INFO")

                        if Decimal(price) == 0:
                            price = data.get("state", {}).get("avg_fill_price", ["0"])[
                                0
                            ]

                        if order_id and status:
                            # Determine order type based on side
                            if side == self.config.close_order_side:
                                order_type = "CLOSE"
                            else:
                                order_type = "OPEN"

                            # Map GRVT status to our status
                            status_map = {
                                "OPEN": "OPEN",
                                "FILLED": "FILLED",
                                "CANCELLED": "CANCELED",
                                "REJECTED": "CANCELED",
                            }
                            mapped_status = status_map.get(status, status)

                            # Handle partially filled orders
                            if status == "OPEN" and Decimal(filled_size) > 0:
                                mapped_status = "PARTIALLY_FILLED"

                            if mapped_status in [
                                "OPEN",
                                "PARTIALLY_FILLED",
                                "FILLED",
                                "CANCELED",
                            ]:
                                # DISABLED: WebSocket position updates to avoid conflicts with REST API
                                # REST API is now the authoritative source (Mean Reversion style)
                                # Position updates are done in place_market_order() and sync_ws_position_if_needed()

                                # if mapped_status == "FILLED":
                                #     fill_qty = (
                                #         Decimal(filled_size)
                                #         if filled_size
                                #         else Decimal(size)
                                #     )
                                #     if side == "buy":
                                #         self._local_position += fill_qty
                                #     else:
                                #         self._local_position -= fill_qty
                                #     self.logger.log(
                                #         f"[WS_POSITION] Updated position: {self._local_position} (+{fill_qty} for {side})",
                                #         "INFO",
                                #     )

                                if self._order_update_handler:
                                    self._order_update_handler(
                                        {
                                            "order_id": order_id,
                                            "side": side,
                                            "order_type": order_type,
                                            "status": mapped_status,
                                            "size": size,
                                            "price": price,
                                            "contract_id": contract_id,
                                            "filled_size": filled_size,
                                        }
                                    )
                            else:
                                self.logger.log(
                                    f"Ignoring order update with status: {mapped_status}",
                                    "DEBUG",
                                )
                        else:
                            self.logger.log(
                                f"Order update missing order_id or status: {data}",
                                "DEBUG",
                            )
                    else:
                        self.logger.log(
                            f"Order update data is not dict or missing legs: {data}",
                            "DEBUG",
                        )
                else:
                    # Handle other message types (position, fill, etc.)
                    method = message.get("method", "unknown")
                    self.logger.log(f"Received non-order message: {method}", "DEBUG")

            except Exception as e:
                self.logger.log(f"Error handling order update: {e}", "ERROR")
                self.logger.log(f"Message that caused error: {message}", "ERROR")

        # Store callback for use after connect
        self._order_update_callback = order_update_callback

        # Subscribe immediately if WebSocket is already initialized; otherwise defer to connect()
        if self._ws_client:
            try:
                asyncio.create_task(
                    self._subscribe_to_orders(self._order_update_callback)
                )
                self.logger.log(
                    f"Successfully initiated subscription to order updates for {self.config.contract_id}",
                    "INFO",
                )
            except Exception as e:
                self.logger.log(f"Error subscribing to order updates: {e}", "ERROR")
                raise
        else:
            self.logger.log(
                "WebSocket not ready yet; will subscribe after connect()", "INFO"
            )

    async def _subscribe_to_orders(self, callback):
        """Subscribe to order updates asynchronously."""
        try:
            await self._ws_client.subscribe(
                stream="order",
                callback=callback,
                ws_end_point_type=GrvtWSEndpointType.TRADE_DATA_RPC_FULL,
                params={"instrument": self.config.contract_id},
            )
            await asyncio.sleep(0)  # Small delay like in test file
            self.logger.log(
                f"Successfully subscribed to order updates for {self.config.contract_id}",
                "INFO",
            )
        except Exception as e:
            self.logger.log(f"Error in subscription task: {e}", "ERROR")

    @query_retry(reraise=True)
    async def fetch_bbo_prices(self, contract_id: str) -> Tuple[Decimal, Decimal]:
        """Fetch best bid and offer prices for a contract."""
        # Get order book from GRVT
        order_book = self.rest_client.fetch_order_book(contract_id, limit=10)

        if not order_book or "bids" not in order_book or "asks" not in order_book:
            raise ValueError(f"Unable to get order book: {order_book}")

        bids = order_book.get("bids", [])
        asks = order_book.get("asks", [])

        best_bid = Decimal(bids[0]["price"]) if bids and len(bids) > 0 else Decimal(0)
        best_ask = Decimal(asks[0]["price"]) if asks and len(asks) > 0 else Decimal(0)

        return best_bid, best_ask

    async def place_post_only_order(
        self, contract_id: str, quantity: Decimal, price: Decimal, side: str
    ) -> OrderResult:
        """Place a post only order with GRVT using official SDK."""

        # Place the order using GRVT SDK
        order_result = self.rest_client.create_limit_order(
            symbol=contract_id,
            side=side,
            amount=quantity,
            price=price,
            params={
                "post_only": True,
                "order_duration_secs": 30 * 86400
                - 1,  # GRVT SDK: signature expired cap is 30 days (default 1 day)
            },
        )
        if not order_result:
            raise Exception(f"[OPEN] Error placing order")

        client_order_id = order_result.get("metadata").get("client_order_id")
        order_status = order_result.get("state").get("status")
        order_status_start_time = time.time()
        order_info = await self.get_order_info(client_order_id=client_order_id)
        if order_info is not None:
            order_status = order_info.status

        while (
            order_status in ["PENDING"] and time.time() - order_status_start_time < 10
        ):
            # Check order status after a short delay
            await asyncio.sleep(0.05)
            order_info = await self.get_order_info(client_order_id=client_order_id)
            if order_info is not None:
                order_status = order_info.status

        if order_status == "PENDING":
            raise Exception("GRVT Server Error: Order not processed after 10 seconds")
        else:
            return order_info


    async def _execute_single_market_order(
        self, contract_id: str, quantity: Decimal, side: str
    ) -> OrderResult:
        """Execute a single market order with retry logic for transient errors."""
        # Get current BBO for price reference
        best_bid, best_ask = await self.fetch_bbo_prices(contract_id)
        expected_price = best_ask if side == "buy" else best_bid

        # Retry loop for transient errors
        max_retries = 3
        for attempt in range(max_retries):
            try:
                # Place the order using GRVT SDK
                order_result = self.rest_client.create_order(
                    symbol=contract_id, order_type="market", side=side, amount=quantity
                )
                
                if not order_result:
                    # ENHANCED: Check path_map for actual response
                    # SDK returns {} but response might be in path_map with order_id
                    path_map = self.rest_client.get_path_return_value_map()

                    # Try to extract order_id from path_map
                    actual_response = None
                    for key in path_map:
                        response = path_map[key]
                        if isinstance(response, dict):
                            # Check for order_id in result or directly in response
                            if "result" in response and response["result"] and "order_id" in response["result"]:
                                actual_response = response["result"]
                                break
                            elif "order_id" in response:
                                actual_response = response
                                break

                    if actual_response and "order_id" in actual_response:
                        # Order was actually created successfully despite SDK returning {}
                        self.logger.log(f"[SINGLE] SDK returned {{}} but order_id found in path_map: {actual_response.get('order_id')}", "INFO")
                        order_result = actual_response
                    else:
                        # Real error - extract and raise
                        error_msg = self._extract_grvt_error("CREATE_ORDER")
                        self.logger.log(f"[SINGLE] Attempt {attempt + 1}/{max_retries}: {error_msg}", "ERROR")

                        # Check if we should retry
                        if attempt < max_retries - 1 and self._is_retriable_error(error_msg):
                            await asyncio.sleep(1 * (attempt + 1))  # Exponential backoff
                            continue
                        else:
                            raise Exception(error_msg)

                # Extract order info
                metadata = order_result.get("metadata", {})
                client_order_id = metadata.get("client_order_id")
                state = order_result.get("state", {})
                order_status = state.get("status", "UNKNOWN")

                self.logger.log(
                    f"[SINGLE] Order placed: {side.upper()} {quantity} @ ~{expected_price} (status: {order_status})",
                    "INFO",
                )

                # Wait for fill confirmation
                start_time = time.time()
                timeout = 30  # 30 seconds timeout for market order

                while order_status in ["PENDING", "OPEN"] and time.time() - start_time < timeout:
                    await asyncio.sleep(0.1)
                    order_info = await self.get_order_info(client_order_id=client_order_id)
                    if order_info:
                        order_status = order_info.status
                        if order_info.status == "FILLED":
                            # CRITICAL FIX: Update local position AFTER confirming with REST API
                            # This ensures _local_position matches the actual exchange position
                            try:
                                # Get actual position from REST API (authoritative source)
                                actual_position = await self.get_account_positions()
                                self._local_position = actual_position
                                self.logger.log(
                                    f"[SINGLE] Filled: {side.upper()} {quantity} @ {order_info.price} (pos: {self._local_position}, synced with REST API)",
                                    "INFO",
                                )
                            except Exception as sync_error:
                                # Fallback to local calculation if REST API fails
                                if side == "buy":
                                    self._local_position += quantity
                                else:
                                    self._local_position -= quantity
                                self.logger.log(
                                    f"[SINGLE] Filled: {side.upper()} {quantity} @ {order_info.price} (pos: {self._local_position}, local calculation)",
                                    "WARNING",
                                )
                            return OrderResult(
                                success=True,
                                order_id=order_info.order_id,
                                side=side,
                                size=quantity,
                                price=order_info.price,
                                status=order_info.status,
                            )

                # Check final status
                if order_status in ["FILLED", "PARTIALLY_FILLED"]:
                    return OrderResult(
                        success=True,
                        order_id=client_order_id,
                        side=side,
                        size=quantity,
                        price=expected_price,
                        status=order_status,
                    )
                else:
                    raise Exception(f"[SINGLE] Order not filled within timeout. Final status: {order_status}")
                    
            except Exception as e:
                error_msg = str(e)
                if attempt < max_retries - 1 and self._is_retriable_error(error_msg):
                    self.logger.log(f"[SINGLE] Retrying after error: {error_msg}", "WARNING")
                    await asyncio.sleep(1 * (attempt + 1))
                    continue
                elif self._is_fatal_error(error_msg):
                    raise
                else:
                    raise

    async def _execute_split_market_order(
        self, contract_id: str, total_quantity: Decimal, side: str
    ) -> OrderResult:
        """Execute split market order with retry logic."""
        from decimal import Decimal
        
        # Calculate chunk size (0.08 ETH max for 1.5 ETH target)
        MAX_CHUNK = Decimal("0.08")
        MIN_CHUNK = Decimal("0.001")  # GRVT minimum order size
        
        chunk_size = min(MAX_CHUNK, total_quantity)
        chunk_size = max(chunk_size, MIN_CHUNK)
        
        remaining = total_quantity
        chunk_num = 0
        
        # Track aggregate results
        total_filled = Decimal("0")
        weighted_price = Decimal("0")
        order_ids = []
        
        self.logger.log(
            f"[SPLIT] Starting {side.upper()} {total_quantity} ETH in chunks of ~{chunk_size}",
            "INFO"
        )
        
        while remaining > MIN_CHUNK:
            chunk_num += 1
            current_chunk = min(chunk_size, remaining)
            
            try:
                self.logger.log(
                    f"[SPLIT] Chunk {chunk_num}: {side.upper()} {current_chunk} ETH (remaining: {remaining})",
                    "INFO"
                )
                
                result = await self._execute_single_market_order(
                    contract_id, current_chunk, side
                )
                
                # Track results
                filled_qty = Decimal(str(result.size)) if result.size else Decimal("0")
                total_filled += filled_qty
                remaining -= filled_qty
                
                if result.success and result.price:
                    weighted_price += Decimal(str(result.price)) * filled_qty
                    order_ids.append(str(result.order_id) if result.order_id else "")
                
                # Delay between chunks to avoid rate limiting
                if remaining > MIN_CHUNK:
                    await asyncio.sleep(0.3)  # 300ms between chunks
                
            except Exception as e:
                error_msg = str(e)
                
                # Check if we should abort or continue
                if self._is_fatal_error(error_msg):
                    self.logger.log(
                        f"[SPLIT] Fatal error at chunk {chunk_num}: {error_msg}",
                        "ERROR"
                    )
                    # Return partial results
                    avg_price = weighted_price / total_filled if total_filled > 0 else Decimal("0")
                    return OrderResult(
                        success=(total_filled > 0),
                        order_id=",".join(order_ids),
                        side=side,
                        size=total_filled,
                        price=avg_price,
                        status="PARTIALLY_FILLED"
                    )
                
                # Retriable error: retry this chunk
                if self._is_retriable_error(error_msg):
                    self.logger.log(
                        f"[SPLIT] Retrying chunk {chunk_num} after error: {error_msg}",
                        "WARNING"
                    )
                    await asyncio.sleep(1)  # Wait before retry
                    continue  # Retry same chunk
                else:
                    # Non-retriable error: abort
                    raise
        
        # Calculate average price
        avg_price = weighted_price / total_filled if total_filled > 0 else Decimal("0")
        
        self.logger.log(
            f"[SPLIT] Completed: {side.upper()} {total_filled}/{total_quantity} "
            f"@ avg {avg_price} in {chunk_num} chunks",
            "INFO"
        )
        
        return OrderResult(
            success=True,
            order_id=",".join(order_ids),
            side=side,
            size=total_filled,
            price=avg_price,
            status="FILLED" if total_filled >= total_quantity * Decimal("0.99") else "PARTIALLY_FILLED"
        )


    def _extract_grvt_error(self, operation: str) -> str:
        """Extract detailed error message from SDK response map."""
        try:
            # SDK stores the full API response before returning {}
            # Try multiple possible endpoint keys
            path_map = self.rest_client.get_path_return_value_map()

            # Try different possible endpoint keys
            possible_keys = [
                "/create_order",
                "create_order",
                "/api/v1/create_order",
                "/api/v1/order/create",
            ]

            for key in possible_keys:
                response = path_map.get(key, {})
                if response:
                    break
            else:
                # No key found - try to get any recent response
                response = list(path_map.values())[-1] if path_map else {}

            # Extract error from response structure
            if response and "error" in response:
                error = response["error"]
                code = error.get("code", "UNKNOWN")
                message = error.get("message", "No details")
                details = error.get("details", {})

                error_parts = [f"[{operation}] {code} - {message}"]
                if details:
                    error_parts.append(f"Details: {details}")
                return " | ".join(error_parts)

            # Check if response has result field (meaning success case called)
            if response and "result" in response:
                result = response.get("result")
                if result is None:
                    return f"[{operation}] API returned null result - Response: {str(response)[:300]}"

            # If we have a response but structure is unexpected
            if response:
                return f"[{operation}] API error - Full response: {str(response)[:300]}"

            return f"[{operation}] Unknown error - No response data available"

        except Exception as e:
            return f"[{operation}] Error extracting error info: {str(e)}"
    
    def _should_split_order(self, quantity: Decimal) -> bool:
        """Determine if order should be split based on size."""
        SPLIT_THRESHOLD = Decimal("0.02")  # Above this, consider splitting
        return quantity > SPLIT_THRESHOLD
    
    def _is_retriable_error(self, error_msg: str) -> bool:
        """Determine if error is retriable."""
        retriable_codes = [
            "INSUFFICIENT_LIQUIDITY",
            "RATE_LIMIT_EXCEEDED",
            "TIMEOUT",
            "NETWORK_ERROR",
            "ORDER_WOULD_IMMEDIATELY_MATCH"
        ]
        error_upper = error_msg.upper()
        return any(code in error_upper for code in retriable_codes)
    
    def _is_fatal_error(self, error_msg: str) -> bool:
        """Determine if error should abort operation."""
        fatal_codes = [
            "INVALID_SIGNATURE",
            "ACCOUNT_MISMATCH",
            "INVALID_SYMBOL",
            "ORDER_TOO_SMALL",
            "AUTHENTICATION_FAILED",
            "UNAUTHORIZED"
        ]
        error_upper = error_msg.upper()
        return any(code in error_upper for code in fatal_codes)

    async def place_market_order(
        self, contract_id: str, quantity: Decimal, side: str
    ) -> OrderResult:
        """Place a market order with GRVT using official SDK.

        ENHANCED: Intelligent splitting for large orders.
        - Orders > 0.02 ETH are split into smaller chunks
        - Small orders execute directly
        - All orders have retry logic for transient failures
        """
        # Check if order should be split
        if self._should_split_order(quantity):
            self.logger.log(f"[MARKET] Large order detected ({quantity} ETH), using split execution", "INFO")
            return await self._execute_split_market_order(contract_id, quantity, side)
        
        # Small order: execute directly with retry logic
        return await self._execute_single_market_order(contract_id, quantity, side)

    async def get_order_price(self, direction: str) -> Decimal:
        """Get the price of an order with GRVT using official SDK."""
        best_bid, best_ask = await self.fetch_bbo_prices(self.config.contract_id)
        if best_bid <= 0 or best_ask <= 0:
            raise ValueError("Invalid bid/ask prices")

        if direction == "buy":
            return best_ask - self.config.tick_size
        elif direction == "sell":
            return best_bid + self.config.tick_size
        else:
            raise ValueError("Invalid direction")

    async def place_open_order(
        self, contract_id: str, quantity: Decimal, direction: str
    ) -> OrderResult:
        """Place an open order with GRVT.

        Improved: Use aggressive limit orders for immediate fills.
        - Places orders at BBO for instant execution
        - Falls back to POST_ONLY if aggressive orders fail
        """
        attempt = 0
        while attempt < 15:
            attempt += 1
            if attempt % 5 == 0:
                self.logger.log(f"[OPEN] Attempt {attempt} to place order", "INFO")
                active_orders = await self.get_active_orders(contract_id)
                active_open_orders = 0
                for order in active_orders:
                    if order.side == self.config.direction:
                        active_open_orders += 1
                if active_open_orders > 1:
                    self.logger.log(
                        f"[OPEN] ERROR: Active open orders abnormal: {active_open_orders}",
                        "ERROR",
                    )
                    raise Exception(
                        f"[OPEN] ERROR: Active open orders abnormal: {active_open_orders}"
                    )

            # Get current market prices
            best_bid, best_ask = await self.fetch_bbo_prices(contract_id)

            if best_bid <= 0 or best_ask <= 0:
                return OrderResult(
                    success=False, error_message="Invalid bid/ask prices"
                )

            # Determine order side and price (AGGRESSIVE for immediate fill)
            if direction == "buy":
                # Place at ASK to ensure immediate fill (cross the spread)
                order_price = best_ask
            elif direction == "sell":
                # Place at BID to ensure immediate fill (cross the spread)
                order_price = best_bid
            else:
                raise Exception(f"[OPEN] Invalid direction: {direction}")

            # Try aggressive limit order first (cross spread)
            try:
                self.logger.log(
                    f"[OPEN] Attempting aggressive order at {order_price} (BBO: {best_bid}/{best_ask})",
                    "INFO",
                )

                order_info = await self.place_post_only_order(
                    contract_id, quantity, order_price, direction
                )

                order_status = order_info.status
                order_id = order_info.order_id

                # If order was filled, we're done
                if order_status == "FILLED":
                    self.logger.log(
                        f"[OPEN] Aggressive order filled immediately at {order_price}",
                        "INFO",
                    )
                    return OrderResult(
                        success=True,
                        order_id=order_id,
                        side=direction,
                        size=quantity,
                        price=order_price,
                        status=order_status,
                    )
                # If order was accepted but not yet filled, wait a bit
                elif order_status == "OPEN":
                    # Wait up to 3 seconds for fill
                    await asyncio.sleep(3)
                    order_info = await self.get_order_info(order_id=order_id)
                    if order_info and order_info.status == "FILLED":
                        return OrderResult(
                            success=True,
                            order_id=order_id,
                            side=direction,
                            size=quantity,
                            price=order_price,
                            status="FILLED",
                        )
                    # Cancel and retry
                    await self.cancel_order(order_id)

            except Exception as e:
                self.logger.log(f"[OPEN] Error placing aggressive order: {e}", "ERROR")

            # Fallback: Try in-spread aggressive maker order
            try:
                if direction == "buy":
                    # Place 1 tick below best ask (aggressive bid in spread)
                    order_price = best_ask - self.config.tick_size
                elif direction == "sell":
                    # Place 1 tick above best bid (aggressive ask in spread)
                    order_price = best_bid + self.config.tick_size
                else:
                    raise Exception(f"[OPEN] Invalid direction: {direction}")

                self.logger.log(
                    f"[OPEN] Fallback: In-spread order at {order_price}",
                    "INFO",
                )

                order_info = await self.place_post_only_order(
                    contract_id, quantity, order_price, direction
                )
            except Exception as e:
                self.logger.log(f"[OPEN] Error placing fallback order: {e}", "ERROR")
                continue

            order_status = order_info.status
            order_id = order_info.order_id

            if order_status == "REJECTED":
                continue
            if order_status in ["OPEN", "FILLED"]:
                return OrderResult(
                    success=True,
                    order_id=order_id,
                    side=direction,
                    size=quantity,
                    price=order_price,
                    status=order_status,
                )
            elif order_status == "PENDING":
                raise Exception("[OPEN] Order not processed after 10 seconds")
            else:
                raise Exception(f"[OPEN] Unexpected order status: {order_status}")

    async def place_close_order(
        self, contract_id: str, quantity: Decimal, price: Decimal, side: str
    ) -> OrderResult:
        """Place a close order with GRVT."""
        # Get current market prices
        attempt = 0
        active_close_orders = await self._get_active_close_orders(contract_id)
        while True:
            attempt += 1
            if attempt % 5 == 0:
                self.logger.log(f"[CLOSE] Attempt {attempt} to place order", "INFO")
                current_close_orders = await self._get_active_close_orders(contract_id)

                if current_close_orders - active_close_orders > 1:
                    self.logger.log(
                        f"[CLOSE] ERROR: Active close orders abnormal: "
                        f"{active_close_orders}, {current_close_orders}",
                        "ERROR",
                    )
                    raise Exception(
                        f"[CLOSE] ERROR: Active close orders abnormal: "
                        f"{active_close_orders}, {current_close_orders}"
                    )
                else:
                    active_close_orders = current_close_orders

            # Adjust price to ensure maker order
            best_bid, best_ask = await self.fetch_bbo_prices(contract_id)

            if side == "sell" and price <= best_bid:
                adjusted_price = best_bid + self.config.tick_size
            elif side == "buy" and price >= best_ask:
                adjusted_price = best_ask - self.config.tick_size
            else:
                adjusted_price = price

            adjusted_price = self.round_to_tick(adjusted_price)
            try:
                order_info = await self.place_post_only_order(
                    contract_id, quantity, adjusted_price, side
                )
            except Exception as e:
                self.logger.log(f"[CLOSE] Error placing order: {e}", "ERROR")
                continue

            order_status = order_info.status
            order_id = order_info.order_id

            if order_status == "REJECTED":
                continue
            if order_status in ["OPEN", "FILLED"]:
                return OrderResult(
                    success=True,
                    order_id=order_id,
                    side=side,
                    size=quantity,
                    price=adjusted_price,
                    status=order_status,
                )
            elif order_status == "PENDING":
                raise Exception("[CLOSE] Order not processed after 10 seconds")
            else:
                raise Exception(f"[CLOSE] Unexpected order status: {order_status}")

    async def cancel_order(self, order_id: str) -> OrderResult:
        """Cancel an order with GRVT."""
        try:
            # Cancel the order using GRVT SDK
            cancel_result = self.rest_client.cancel_order(id=order_id)

            if cancel_result:
                return OrderResult(success=True)
            else:
                return OrderResult(
                    success=False, error_message="Failed to cancel order"
                )

        except Exception as e:
            return OrderResult(success=False, error_message=str(e))

    @query_retry(reraise=True)
    async def get_order_info(
        self, order_id: str = None, client_order_id: str = None
    ) -> Optional[OrderInfo]:
        """Get order information from GRVT."""
        # Get order information using GRVT SDK
        if order_id is not None:
            order_data = self.rest_client.fetch_order(id=order_id)
        elif client_order_id is not None:
            order_data = self.rest_client.fetch_order(
                params={"client_order_id": client_order_id}
            )
        else:
            raise ValueError("Either order_id or client_order_id must be provided")

        if not order_data or "result" not in order_data:
            raise ValueError(f"Unable to get order info: {order_id}")

        order = order_data["result"]
        legs = order.get("legs", [])
        if not legs:
            raise ValueError(f"Unable to get order info: {order_id}")

        leg = legs[0]  # Get first leg
        state = order.get("state", {})

        return OrderInfo(
            order_id=order.get("order_id", ""),
            side=leg.get("is_buying_asset", False) and "buy" or "sell",
            size=Decimal(leg.get("size", 0)),
            price=Decimal(leg.get("limit_price", 0)),
            status=state.get("status", ""),
            filled_size=(
                Decimal(state.get("traded_size", ["0"])[0])
                if isinstance(state.get("traded_size"), list)
                else Decimal(0)
            ),
            remaining_size=(
                Decimal(state.get("book_size", ["0"])[0])
                if isinstance(state.get("book_size"), list)
                else Decimal(0)
            ),
        )

    async def _get_active_close_orders(self, contract_id: str) -> int:
        """Get active close orders for a contract using official SDK."""
        active_orders = await self.get_active_orders(contract_id)
        active_close_orders = 0
        for order in active_orders:
            if order.side == self.config.close_order_side:
                active_close_orders += 1
        return active_close_orders

    @query_retry(reraise=True)
    async def get_active_orders(self, contract_id: str) -> List[OrderInfo]:
        """Get active orders for a contract."""
        # Get active orders using GRVT SDK
        orders = self.rest_client.fetch_open_orders(symbol=contract_id)

        if not orders:
            return []

        order_list = []
        for order in orders:
            legs = order.get("legs", [])
            if not legs:
                continue

            leg = legs[0]  # Get first leg
            state = order.get("state", {})

            order_list.append(
                OrderInfo(
                    order_id=order.get("order_id", ""),
                    side=leg.get("is_buying_asset", False) and "buy" or "sell",
                    size=Decimal(leg.get("size", 0)),
                    price=Decimal(leg.get("limit_price", 0)),
                    status=state.get("status", ""),
                    filled_size=(
                        Decimal(state.get("traded_size", ["0"])[0])
                        if isinstance(state.get("traded_size"), list)
                        else Decimal(0)
                    ),
                    remaining_size=(
                        Decimal(state.get("book_size", ["0"])[0])
                        if isinstance(state.get("book_size"), list)
                        else Decimal(0)
                    ),
                )
            )

        return order_list

    @query_retry(reraise=True)
    async def get_account_positions(self) -> Decimal:
        """Get account positions."""
        # Get positions using GRVT SDK
        positions = self.rest_client.fetch_positions()

        for position in positions:
            if position.get("instrument") == self.config.contract_id:
                return Decimal(position.get("size", 0))

        return Decimal(0)

    async def get_contract_attributes(self) -> Tuple[str, Decimal]:
        """Get contract ID and tick size for a ticker."""
        ticker = self.config.ticker
        if not ticker:
            raise ValueError("Ticker is empty")

        # Get markets from GRVT
        markets = self.rest_client.fetch_markets()

        for market in markets:
            if (
                market.get("base") == ticker
                and market.get("quote") == "USDT"
                and market.get("kind") == "PERPETUAL"
            ):
                self.config.contract_id = market.get("instrument", "")
                self.config.tick_size = Decimal(market.get("tick_size", 0))

                # Validate minimum quantity
                min_size = Decimal(market.get("min_size", 0))
                if self.config.quantity < min_size:
                    raise ValueError(
                        f"Order quantity is less than min quantity: {self.config.quantity} < {min_size}"
                    )

                return self.config.contract_id, self.config.tick_size

        raise ValueError(f"Contract not found for ticker: {ticker}")
