# Fix Subaccount and Close Position Bugs - Implementation Plan

**Plan ID**: FIX-SUBACCOUNT-CLOSE-BUGS-001
**Created**: 2026-01-31
**Status**: DRAFT
**Priority**: CRITICAL

---

## Executive Summary

This plan addresses three critical bugs in the DN pair trading bot that cause position accumulation and prevent proper position closing:

1. **Bug 1**: Subaccount address mismatch between order placement and position checking
2. **Bug 2**: Missing `isolated_margin` parameter in `place_close_order`
3. **Bug 3**: Position accumulation symptom caused by bugs 1 and 2

**Impact**: Positions never close, causing uncontrolled leverage growth (observed ~14x leverage vs expected 5x)

---

## Context

### Original Request

Fix critical bugs in the DN pair trading bot that cause:
- `get_account_positions()` always returns 0 even when positions are open
- Close orders fail or don't execute immediately
- Position accumulation with excessive leverage usage

### Codebase Analysis

**Primary File**: `/Users/botfarmer/2dex/hedge/exchanges/nado.py`

**Key Findings**:
- Line 69: Uses `self.owner = self.client.context.engine_client.signer.address` for order placement
- Line 986: Uses `self.client.context.signer.address` for position checking
- These are different addresses, causing the subaccount mismatch
- `place_close_order` (lines 749-825) lacks `isolated_margin` parameter
- `place_close_order` uses `POST_ONLY` instead of `IOC`, inappropriate for closing

### SDK Architecture Documentation

**Understanding the Dual Address Structure**:

The Nado SDK uses a layered client architecture that creates TWO distinct signer addresses:

1. **`self.client.context.engine_client.signer.address`** (Line 69, 986):
   - This is the raw signer address from the engine client layer
   - Used for: Subaccount derivation, cryptographic signing
   - Generated by: The low-level StarkNet engine client
   - Purpose: Transaction signature generation

2. **`self.client.context.signer.address`** (Line 986 - BUG SOURCE):
   - This is a higher-level context signer address
   - May represent a different derivation path or account abstraction
   - Does NOT match the address used for order placement

**Why the Addresses Differ**:
- The SDK separates signing concerns between engine operations and account operations
- `engine_client.signer` is the canonical address for subaccount operations
- `context.signer` is used for higher-level account management but differs in derivation
- When calling `get_subaccount_info()`, the SDK expects the engine_client signer address to match what was used for order placement

**Verification from Code**:
```python
# Line 69: Order placement uses engine_client.signer.address
self.owner = self.client.context.engine_client.signer.address

# Lines 528-541: place_open_order uses self.owner
order = OrderParams(
    sender=SubaccountParams(
        subaccount_owner=self.owner,  # Uses engine_client.signer.address
        ...
    )
)

# Line 986: BUG - position checking uses different address
resolved_subaccount = subaccount_to_hex(self.client.context.signer.address, self.subaccount_name)
# This creates a DIFFERENT subaccount than where orders were placed!
```

**Grepped Verification Results**:
```bash
# grep -n "signer\.address" hedge/exchanges/nado.py
69:        self.owner = self.client.context.engine_client.signer.address
986:            resolved_subaccount = subaccount_to_hex(self.client.context.signer.address, self.subaccount_name)
```

Only TWO instances of `signer.address` usage exist:
- Line 69: Correctly sets `self.owner` from engine_client
- Line 986: INCORRECTLY uses `context.signer.address` (should use `self.owner`)

### Current Evidence

- Expected: $100 notional / 5x leverage = $20 margin per position
- Actual: $288 SOL margin, $279 ETH margin (~14x leverage)
- Ratio: $288 / ($100 / 0.7x) ≈ 2.0x indicates ~2 positions accumulated

---

## Work Objectives

### Core Objective

Fix the subaccount address mismatch and close order implementation to enable proper position detection and closing.

### Deliverables

1. **Code Changes**
   - Fix subaccount address consistency across all methods
   - Add `isolated_margin` calculation to `place_close_order`
   - Change `place_close_order` to use IOC order type
   - Add proper expiration time to close orders

2. **Testing**
   - Unit tests for position checking with correct address
   - Integration tests for close order execution
   - Live test with small position size

3. **Verification**
   - Positions are detected correctly
   - Close orders execute immediately
   - No position accumulation after multiple iterations

### Definition of Done

- [ ] All code changes implemented and committed
- [ ] Unit tests pass with 100% success rate
- [ ] Integration tests pass with correct position detection
- [ ] Live test completes 5 iterations with no position accumulation
- [ ] Final position check shows 0 (within tolerance of 0.001)
- [ ] Code review approved

---

## Must Have / Must NOT Have

### Must Have

**Bug Fix 1: Subaccount Address Consistency**
- Use `self.owner` consistently across all methods
- Update `get_account_positions()` to use `self.owner`
- Update `cancel_order()` to use `self.owner`
- Update `get_active_orders()` to use `self.owner`
- Add logging to verify address consistency

**Bug Fix 2: Close Order Implementation**
- Add `isolated_margin` calculation to `place_close_order`
- Change order type from `POST_ONLY` to `IOC`
- Update expiration to 60 seconds (same as `place_ioc_order`)
- Add quantity rounding to size increment
- Add proper error handling and logging

**Testing Requirements**
- Unit test for address consistency
- Integration test for close order execution
- Live test with small size ($10 notional)
- Verification of position closing after 5 iterations

### Must NOT Have

- **DO NOT** modify `place_open_order` or `place_ioc_order` (they work correctly)
- **DO NOT** change the WebSocket implementation
- **DO NOT** modify the BBO or BookDepth handlers
- **DO NOT** change leverage calculation (5x is correct)
- **DO NOT** add new dependencies

---

## Detailed Implementation Steps

### Phase 0: Detect and Clean Orphaned Positions

**IMPORTANT**: Before fixing the code, we must identify and handle existing positions placed on the wrong subaccount.

#### Step 0.1: Detect Orphaned Positions

**Purpose**: Find any positions that exist on the "wrong" subaccount (using `context.signer.address`)

**Detection Script**: `/Users/botfarmer/2dex/hedge/scripts/detect_orphaned_positions.py`

```python
"""Detect positions on both possible subaccount addresses."""
import os
import asyncio
from decimal import Decimal
from nado_protocol.client import create_nado_client, NadoClientMode
from nado_protocol.engine_client.types import OrderParams
from nado_protocol.utils.subaccount import SubaccountParams
from nado_protocol.utils.bytes32 import subaccount_to_hex
from nado_protocol.utils.math import from_x18

async def detect_orphaned_positions():
    """Check both addresses for positions."""
    private_key = os.getenv('NADO_PRIVATE_KEY')
    mode = os.getenv('NADO_MODE', 'MAINNET').upper()
    subaccount_name = os.getenv('NADO_SUBACCOUNT_NAME', 'default')

    mode_map = {
        'MAINNET': NadoClientMode.MAINNET,
        'DEVNET': NadoClientMode.DEVNET,
    }
    client_mode = mode_map.get(mode, NadoClientMode.MAINNET)
    client = create_nado_client(client_mode, private_key)

    # Get both addresses
    engine_client_address = client.context.engine_client.signer.address
    context_address = client.context.signer.address

    print(f"Engine Client Address (used for orders): {engine_client_address}")
    print(f"Context Signer Address (buggy, used for position checks): {context_address}")
    print(f"Addresses match: {engine_client_address == context_address}")
    print()

    # Check both addresses for positions
    products = [4, 8]  # ETH, SOL

    for product_id in products:
        ticker = "ETH" if product_id == 4 else "SOL"

        # Check engine_client address (correct)
        engine_subaccount = subaccount_to_hex(engine_client_address, subaccount_name)
        try:
            engine_data = client.context.engine_client.get_subaccount_info(engine_subaccount)
            for pos in engine_data.perp_balances:
                if pos.product_id == product_id:
                    size = Decimal(str(from_x18(pos.balance.amount)))
                    if size != 0:
                        print(f"[ENGINE_CLIENT] {ticker}: {size} (CORRECT address)")
        except Exception as e:
            print(f"[ENGINE_CLIENT] {ticker}: Error - {e}")

        # Check context address (buggy, may have orphaned positions)
        context_subaccount = subaccount_to_hex(context_address, subaccount_name)
        try:
            context_data = client.context.engine_client.get_subaccount_info(context_subaccount)
            for pos in context_data.perp_balances:
                if pos.product_id == product_id:
                    size = Decimal(str(from_x18(pos.balance.amount)))
                    if size != 0:
                        print(f"[CONTEXT_SIGNER] {ticker}: {size} (ORPHANED on wrong address)")
        except Exception as e:
            print(f"[CONTEXT_SIGNER] {ticker}: Error - {e}")

if __name__ == "__main__":
    asyncio.run(detect_orphaned_positions())
```

**Acceptance Criteria**:
- Script runs without errors
- Reports positions on both addresses
- Clearly labels which address each position belongs to
- Identifies any orphaned positions on the wrong address

#### Step 0.2: Cleanup Procedure for Orphaned Positions

**Options for Handling Orphaned Positions**:

1. **Option A: Manual Close via Nado Dashboard**
   - Log into Nado dashboard
   - Navigate to the specific subaccount (using context.signer.address)
   - Manually close all positions
   - Verify balance returns to zero

2. **Option B: Automated Close Script**
   - Create temporary client using context.signer.address
   - Place IOC orders to close orphaned positions
   - Verify closure
   - Delete temporary code after use

**Cleanup Script**: `/Users/botfarmer/2dex/hedge/scripts/cleanup_orphaned_positions.py`

```python
"""Close orphaned positions on the wrong subaccount."""
import os
import asyncio
from decimal import Decimal
from nado_protocol.client import create_nado_client, NadoClientMode
from nado_protocol.utils.subaccount import SubaccountParams
from nado_protocol.utils.bytes32 import subaccount_to_hex
from nado_protocol.utils.math import to_x18, from_x18
from nado_protocol.utils.expiration import get_expiration_timestamp
from nado_protocol.utils.nonce import gen_order_nonce
from nado_protocol.utils.order import build_appendix, OrderType

async def cleanup_orphaned_positions():
    """Close positions on the context.signer.address subaccount."""
    private_key = os.getenv('NADO_PRIVATE_KEY')
    mode = os.getenv('NADO_MODE', 'MAINNET').upper()
    subaccount_name = os.getenv('NADO_SUBACCOUNT_NAME', 'default')

    mode_map = {
        'MAINNET': NadoClientMode.MAINNET,
        'DEVNET': NadoClientMode.DEVNET,
    }
    client_mode = mode_map.get(mode, NadoClientMode.MAINNET)
    client = create_nado_client(client_mode, private_key)

    # Use the WRONG address (context.signer) to access orphaned positions
    orphaned_owner = client.context.signer.address
    print(f"Cleaning up positions on orphaned address: {orphaned_owner}")

    products = {
        4: ("ETH", "0.0001"),
        8: ("SOL", "0.01"),
    }

    for product_id, (ticker, price_increment) in products.items():
        # Get position
        orphaned_subaccount = subaccount_to_hex(orphaned_owner, subaccount_name)
        try:
            data = client.context.engine_client.get_subaccount_info(orphaned_subaccount)
            for pos in data.perp_balances:
                if pos.product_id == product_id:
                    size = Decimal(str(from_x18(pos.balance.amount)))
                    if size == 0:
                        continue

                    print(f"\nClosing orphaned {ticker} position: {size}")

                    # Determine close side
                    side = 'sell' if size > 0 else 'buy'
                    close_qty = abs(size)

                    # Get BBO
                    ticker_id = "ETH-PERP_USDT0" if product_id == 4 else "SOL-PERP_USDT0"
                    orderbook = client.context.engine_client.get_orderbook(ticker_id=ticker_id, depth=1)
                    if not orderbook or not orderbook.bids or not orderbook.asks:
                        print(f"  ERROR: Cannot get orderbook for {ticker}")
                        continue

                    best_bid = Decimal(str(orderbook.bids[0][0]))
                    best_ask = Decimal(str(orderbook.asks[0][0]))

                    # Taker pricing for IOC
                    close_price = best_bid if side == 'sell' else best_ask

                    # Build IOC order to close
                    order = OrderParams(
                        sender=SubaccountParams(
                            subaccount_owner=orphaned_owner,
                            subaccount_name=subaccount_name,
                        ),
                        priceX18=to_x18(float(close_price)),
                        amount=to_x18(float(close_qty)) if side == 'buy' else -to_x18(float(close_qty)),
                        expiration=get_expiration_timestamp(60),
                        nonce=gen_order_nonce(),
                        appendix=build_appendix(
                            order_type=OrderType.IOC,
                            isolated=True,
                        )
                    )

                    # Place close order
                    result = client.market.place_order({"product_id": product_id, "order": order})
                    if result:
                        print(f"  SUCCESS: Closed {close_qty} @ ${close_price}")
                    else:
                        print(f"  ERROR: Order placement failed")
        except Exception as e:
            print(f"  ERROR: {e}")

if __name__ == "__main__":
    print("WARNING: This will close positions on the ORPHANED subaccount.")
    confirm = input("Continue? (yes/no): ")
    if confirm.lower() == 'yes':
        asyncio.run(cleanup_orphaned_positions())
```

**Acceptance Criteria**:
- All orphaned positions closed
- Final balance on orphaned subaccount is 0
- No new positions affected

### Phase 1: Fix Subaccount Address Mismatch

#### Step 1.1: Verify Complete Fix with Grep

**Verification Command**:
```bash
# After fix, verify NO instances of context.signer.address remain in order methods
grep -n "context\.signer\.address" hedge/exchanges/nado.py
```

**Expected Result**:
- No matches found (all instances replaced with `self.owner`)
- OR: Only matches in comments/docstrings explaining the bug

**Acceptance Criteria**:
- Zero functional uses of `context.signer.address` in order/position methods
- All order operations use `self.owner` consistently

#### Step 1.2: Update `get_account_positions()` Method

**File**: `/Users/botfarmer/2dex/hedge/exchanges/nado.py`
**Lines**: 981-1005

**Current Code**:
```python
@query_retry(default_return=0)
async def get_account_positions(self) -> Decimal:
    """Get account positions using official SDK."""
    try:
        # Get subaccount identifier
        resolved_subaccount = subaccount_to_hex(self.client.context.signer.address, self.subaccount_name)

        # Get isolated positions from Nado SDK (requires subaccount parameter)
        account_data = self.client.context.engine_client.get_subaccount_info(resolved_subaccount)
        position_data = account_data.perp_balances

        # Find position for current contract
        product_id = self.config.contract_id

        for position in position_data:
            if position.product_id == product_id:
                position_size = position.balance.amount
                return Decimal(str(from_x18(position_size)))

        return Decimal(0)

    except Exception as e:
        self.logger.log(f"Error getting account positions: {e}", "ERROR")
        self.logger.log(f"Traceback: {traceback.format_exc()}", "ERROR")
        return Decimal(0)
```

**Updated Code**:
```python
@query_retry(default_return=0)
async def get_account_positions(self) -> Decimal:
    """Get account positions using official SDK."""
    try:
        # CRITICAL FIX: Use self.owner for consistency with order placement
        resolved_subaccount = subaccount_to_hex(self.owner, self.subaccount_name)

        # Log the address being used for debugging
        self.logger.log(f"get_account_positions using owner: {self.owner}", "DEBUG")

        # Get isolated positions from Nado SDK (requires subaccount parameter)
        account_data = self.client.context.engine_client.get_subaccount_info(resolved_subaccount)
        position_data = account_data.perp_balances

        # Find position for current contract
        product_id = self.config.contract_id

        for position in position_data:
            if position.product_id == product_id:
                position_size = position.balance.amount
                position_size_decimal = Decimal(str(from_x18(position_size)))
                self.logger.log(f"Found position: product_id={product_id}, size={position_size_decimal}", "DEBUG")
                return position_size_decimal

        self.logger.log(f"No position found for product_id={product_id}", "DEBUG")
        return Decimal(0)

    except Exception as e:
        self.logger.log(f"Error getting account positions: {e}", "ERROR")
        self.logger.log(f"Traceback: {traceback.format_exc()}", "ERROR")
        return Decimal(0)
```

**Acceptance Criteria**:
- Method uses `self.owner` instead of `self.client.context.signer.address`
- Debug logging added to track address and position detection
- Returns correct position size when positions exist

#### Step 1.3: Verify Other Methods Use Consistent Address

**Methods to Check**:
- `cancel_order()` (lines 827-851)
- `get_active_orders()` (lines 931-979)

**Action**: Verify these methods already use `self.owner` (they do, lines 830, 936)

**Acceptance Criteria**:
- All order-related methods use `self.owner`
- No remaining instances of `self.client.context.signer.address` in order methods

### Phase 2: Fix `place_close_order` Implementation

#### Step 2.1: Fee Impact Analysis - IOC vs POST_ONLY

**Fee Structure Comparison**:

| Order Type | Fee Rate | Execution | Fee on $100 Position |
|------------|----------|-----------|----------------------|
| POST_ONLY (maker) | 2 bps (0.02%) | No guarantee | $0.02 |
| IOC (taker) | 5 bps (0.05%) | Immediate | $0.05 |

**Fee Difference Analysis**:
- Per $100 position: $0.03 extra for IOC
- Per $1000 position: $0.30 extra for IOC
- Per DN pair (2 legs): $0.06 extra for IOC

**Trade-off Analysis**:

**POST_ONLY (Current Buggy Implementation)**:
- Advantages: Lower fees (2 bps)
- Disadvantages:
  - No execution guarantee
  - Order may sit in book indefinitely
  - Positions never close (observed bug)
  - Accumulation causes 14x leverage instead of 5x

**IOC (Proposed Fix)**:
- Advantages:
  - Guaranteed immediate execution or cancellation
  - Positions close cleanly
  - No accumulation
  - Predictable behavior
- Disadvantages:
  - Higher fees (5 bps vs 2 bps)
  - May experience slippage on thin books

**Recommendation**: Use IOC despite higher fees because:
1. The fee difference is negligible ($0.03 per $100 position)
2. Position accumulation causes FAR more cost (14x leverage vs 5x)
3. Guaranteed execution is critical for risk management
4. Slippage is minimal for small sizes (<$100 notional)

#### Step 2.2: Add Isolated Margin Calculation and IOC Order Type

**File**: `/Users/botfarmer/2dex/hedge/exchanges/nado.py`
**Lines**: 749-825

**Current Code**:
```python
async def place_close_order(self, contract_id: str, quantity: Decimal, price: Decimal, side: str) -> OrderResult:
    """Place a close order with Nado using official SDK."""
    max_retries = 5
    retry_count = 0

    while retry_count < max_retries:
        try:
            best_bid, best_ask = await self.fetch_bbo_prices(contract_id)

            if best_bid <= 0 or best_ask <= 0:
                return OrderResult(success=False, error_message='Invalid bid/ask prices')

            # Adjust order price based on market conditions
            adjusted_price = price
            if side.lower() == 'sell':
                # For sell orders, ensure price is above best bid to be a maker order
                if price <= best_bid:
                    adjusted_price = best_bid + self.config.tick_size
            elif side.lower() == 'buy':
                # For buy orders, ensure price is below best ask to be a maker order
                if price >= best_ask:
                    adjusted_price = best_ask - self.config.tick_size

            # Build order parameters
            order = OrderParams(
                sender=SubaccountParams(
                    subaccount_owner=self.owner,
                    subaccount_name=self.subaccount_name,
                ),
                priceX18=to_x18(float(adjusted_price)),
                amount=to_x18(float(quantity)) if side.lower() == 'buy' else -to_x18(float(quantity)),
                expiration=get_expiration_timestamp(3600),  # 1 hour expiration
                nonce=gen_order_nonce(),
                appendix=build_appendix(
                    order_type=OrderType.POST_ONLY,
                    isolated=True
                )
            )

            # Place the order
            result = self.client.market.place_order({"product_id": int(contract_id), "order": order})

            if not result:
                return OrderResult(success=False, error_message='Failed to place order')

            # Extract order ID from response
            order_id = result.data.digest
            if not order_id:
                await asyncio.sleep(0.1)
                return OrderResult(
                    success=True,
                    side=side,
                    size=quantity,
                    price=adjusted_price,
                    status='OPEN'
                )

            # Order successfully placed
            return OrderResult(
                success=True,
                order_id=order_id,
                side=side,
                size=quantity,
                price=adjusted_price,
                status='OPEN'
            )

        except Exception as e:
            self.logger.log(f"Error placing close order: {e}", "ERROR")
            if retry_count < max_retries - 1:
                retry_count += 1
                await asyncio.sleep(0.1)
                continue
            else:
                return OrderResult(success=False, error_message=str(e))

    return OrderResult(success=False, error_message='Max retries exceeded for close order')
```

**Updated Code**:
```python
async def place_close_order(self, contract_id: str, quantity: Decimal, price: Decimal, side: str) -> OrderResult:
    """Place a close order with Nado using official SDK.

    CRITICAL FIXES:
    - Uses IOC order type for immediate execution (not POST_ONLY)
    - Includes isolated_margin calculation (required for isolated margin trading)
    - Rounds quantity to size increment (same as place_ioc_order)
    - Short expiration (60s) for immediate-or-cancel behavior
    """
    max_retries = 3
    retry_count = 0

    while retry_count < max_retries:
        try:
            best_bid, best_ask = await self.fetch_bbo_prices(contract_id)

            if best_bid <= 0 or best_ask <= 0:
                return OrderResult(success=False, error_message='Invalid bid/ask prices')

            # Convert to product_id int
            product_id_int = int(contract_id)

            # Use taker pricing for IOC: match with standing orders at the touch
            if side.lower() == 'buy':
                # Buy at best ask to match with standing sell orders
                order_price = self._round_price_to_increment(product_id_int, best_ask)
            else:
                # Sell at best bid to match with standing buy orders
                order_price = self._round_price_to_increment(product_id_int, best_bid)

            # CRITICAL: Round quantity to size increment FIRST
            rounded_quantity = self._round_quantity_to_size_increment(product_id_int, quantity)
            if rounded_quantity == 0:
                return OrderResult(success=False, error_message=f'Quantity {quantity} too small (rounds to 0)')

            # CRITICAL FIX: Calculate isolated margin for 5x leverage
            # SDK requires x6 precision (6 decimal places) for isolated_margin parameter
            notional_value = float(str(rounded_quantity)) * float(str(order_price))
            leverage = 5.0
            isolated_margin = int(notional_value / leverage * 10**6)  # x6 precision

            self.logger.log(
                f"Close order: {side} {rounded_quantity} @ ${order_price}, "
                f"notional=${notional_value:.2f}, margin=${notional_value/leverage:.2f}",
                "INFO"
            )

            # Build order parameters with isolated_margin
            order = OrderParams(
                sender=SubaccountParams(
                    subaccount_owner=self.owner,
                    subaccount_name=self.subaccount_name,
                ),
                priceX18=to_x18(float(str(order_price))),
                amount=to_x18(float(str(rounded_quantity))) if side.lower() == 'buy' else -to_x18(float(str(rounded_quantity))),
                expiration=get_expiration_timestamp(60),  # CRITICAL FIX: Short expiration for IOC
                nonce=gen_order_nonce(),
                appendix=build_appendix(
                    order_type=OrderType.IOC,  # CRITICAL FIX: IOC for immediate execution
                    isolated=True,
                    isolated_margin=isolated_margin  # CRITICAL FIX: Required for isolated margin
                )
            )

            # Place the order
            result = self.client.market.place_order({"product_id": product_id_int, "order": order})

            if not result:
                return OrderResult(
                    success=False,
                    error_message='Failed to place order',
                    status='EXPIRED'
                )

            order_id = result.data.digest

            # Immediately check order status to see if it filled
            await asyncio.sleep(0.1)  # Brief wait for execution
            order_info = await self.get_order_info(order_id)

            if order_info is None:
                return OrderResult(
                    success=False,
                    error_message='Could not get order info',
                    status='UNKNOWN'
                )

            # Determine filled status
            filled_size = order_info.filled_size
            remaining_size = order_info.remaining_size

            if remaining_size == 0:
                status = 'FILLED'
            elif filled_size > 0:
                status = 'PARTIALLY_FILLED'
            else:
                status = 'EXPIRED'

            # Success only if there was actual fill
            actual_fill = filled_size != 0
            return OrderResult(
                success=actual_fill,
                order_id=order_id,
                side=side,
                size=rounded_quantity,
                filled_size=abs(filled_size) if filled_size != 0 else Decimal('0'),
                price=order_info.price,
                status=status
            )

        except Exception as e:
            self.logger.log(f"Error placing close order: {e}", "ERROR")
            if retry_count < max_retries - 1:
                retry_count += 1
                await asyncio.sleep(0.05)
                continue
            else:
                return OrderResult(success=False, error_message=str(e))

    return OrderResult(success=False, error_message='Max retries exceeded for close order')
```

**Acceptance Criteria**:
- Method uses IOC order type instead of POST_ONLY
- Isolated margin calculated with x6 precision
- Quantity rounded to size increment
- Uses taker pricing (best bid for sell, best ask for buy)
- Returns proper fill status (FILLED, PARTIALLY_FILLED, EXPIRED)
- Returns success=False if no fill occurred

---

## Testing Strategy

### Test 1: Unit Test for Address Consistency

**File**: `/Users/botfarmer/2dex/hedge/tests/test_nado_address_consistency.py`

**Purpose**: Verify that all order-related methods use the same address

**Test Cases**:
1. Verify `self.owner` is set correctly in `__init__`
2. Verify `get_account_positions()` uses `self.owner`
3. Verify `cancel_order()` uses `self.owner`
4. Verify `get_active_orders()` uses `self.owner`
5. Verify `place_open_order()` uses `self.owner`
6. Verify `place_ioc_order()` uses `self.owner`
7. Verify `place_close_order()` uses `self.owner`

**Specific Assertions**:
```python
def test_owner_set_from_engine_client():
    """Test that self.owner uses engine_client.signer.address."""
    client = NadoClient(config)
    assert client.owner == client.client.context.engine_client.signer.address
    assert client.owner != client.client.context.signer.address  # These differ!

def test_get_account_positions_uses_owner():
    """Test that get_account_positions uses self.owner for subaccount lookup."""
    with patch.object(client, 'owner') as mock_owner:
        mock_owner.return_value = "0xcorrect_address"
        await client.get_account_positions()
        # Verify subaccount_to_hex was called with self.owner
        mock_subaccount.assert_called_with("0xcorrect_address", client.subaccount_name)

def test_no_context_signer_in_position_methods():
    """Verify no methods use context.signer.address (grep verification)."""
    import subprocess
    result = subprocess.run(
        ['grep', '-n', 'context\\.signer\\.address', 'hedge/exchanges/nado.py'],
        capture_output=True, text=True
    )
    # Should only find in comments, not in functional code
    assert 'context.signer.address' not in result.stdout or '# BUG' in result.stdout
```

**Mock Requirements**:
- Mock NadoClient creation
- Mock SDK context and signer with different addresses
- Verify address values match across all calls

**Expected Output**: All tests pass, address consistency verified

### Test 2: Integration Test for Position Detection

**File**: `/Users/botfarmer/2dex/hedge/tests/test_nado_position_detection.py`

**Purpose**: Verify that `get_account_positions()` correctly detects open positions

**Test Cases**:
1. Open a small position ($10 notional)
2. Call `get_account_positions()`
3. Verify position size matches expected (within 0.1 SOL tolerance - see Note below)
4. Close the position
5. Verify `get_account_positions()` returns 0

**Specific Assertions**:
```python
async def test_position_detection_after_open():
    """Test that positions are detected after opening."""
    # Open position
    result = await client.place_ioc_order(contract_id, quantity, 'buy')
    assert result.success
    assert result.status == 'FILLED'

    # Check position detection
    detected = await client.get_account_positions()
    expected_qty = quantity
    tolerance = Decimal('0.1') if product_id == 8 else Decimal('0.001')  # SOL vs ETH
    assert abs(detected - expected_qty) < tolerance, f"Expected {expected_qty}, got {detected}"

async def test_position_zero_after_close():
    """Test that position returns to zero after closing."""
    # Open and close
    await client.place_ioc_order(contract_id, quantity, 'buy')
    await client.place_close_order(contract_id, quantity, price, 'sell')

    # Verify zero
    position = await client.get_account_positions()
    tolerance = Decimal('0.1') if product_id == 8 else Decimal('0.001')
    assert position <= tolerance, f"Position should be ~0, got {position}"
```

**Requirements**:
- Use devnet or testnet environment
- Use small size to minimize risk
- Clean up any open positions after test

**NOTE: Tolerance Correction**:
- SOL tolerance: 0.1 (not 0.001 - SOL minimum size is 0.1)
- ETH tolerance: 0.001 (ETH minimum size is 0.001)

**Expected Output**:
- Position detected with correct size after opening
- Position returns to 0 after closing

### Test 3: Integration Test for Close Order

**File**: `/Users/botfarmer/2dex/hedge/tests/test_nado_close_order.py`

**Purpose**: Verify that `place_close_order` executes immediately

**Test Cases**:
1. Open a small position ($10 notional)
2. Call `place_close_order` with IOC type
3. Verify order status is FILLED (not OPEN)
4. Verify `get_account_positions()` returns 0
5. Check no remaining open orders

**Specific Assertions for isolated_margin Calculation**:
```python
async def test_close_order_isolated_margin_calculation():
    """Test that isolated_margin is calculated correctly."""
    # Setup
    quantity = Decimal('0.1')  # ETH
    price = Decimal('3000')
    notional = float(quantity) * float(price)  # 300.0
    expected_margin = notional / 5.0  # 60.0
    expected_margin_x6 = int(expected_margin * 10**6)  # 60000000

    # Mock the SDK call and verify appendix
    with patch.object(client.client.market, 'place_order') as mock_place:
        await client.place_close_order('4', quantity, price, 'sell')

        # Get the order that was placed
        call_args = mock_place.call_args
        order_params = call_args[0][1]['order']

        # Verify isolated_margin in appendix
        assert hasattr(order_params.appendix, 'isolated_margin')
        assert order_params.appendix.isolated_margin == expected_margin_x6

async def test_close_order_ioc_status_determination():
    """Test that order status is determined correctly from get_order_info."""
    # Verify get_order_info returns correct types
    order_info = await client.get_order_info(order_id)

    # Type assertions
    assert isinstance(order_info, OrderInfo)
    assert isinstance(order_info.filled_size, Decimal)
    assert isinstance(order_info.remaining_size, Decimal)

    # Status logic verification
    if order_info.remaining_size == 0:
        assert order_info.status == 'FILLED'
    elif order_info.filled_size > 0:
        assert order_info.status == 'PARTIALLY_FILLED'
    else:
        assert order_info.status == 'EXPIRED'
```

**OrderInfo Data Type Verification**:
The `get_order_info()` method (lines 854-929) returns:
- `filled_size: Decimal` (calculated as `size - remaining_size`)
- `remaining_size: Decimal` (from `unfilled_amount` converted via `from_x18()`)
- `price: Decimal` (from `price_x18` converted via `from_x18()`)

**Status Determination Logic**:
```
if remaining_size == 0:
    status = 'FILLED'
elif filled_size > 0:
    status = 'PARTIALLY_FILLED'
else:
    status = 'EXPIRED'
```

**Requirements**:
- Use devnet or testnet environment
- Use small size to minimize risk
- Verify no partial fills (full close expected)

**Expected Output**:
- Order status is FILLED
- Position returns to 0
- No open orders remain
- isolated_margin calculated correctly

### Test 4: Live Test with Multiple Iterations

**File**: `/Users/botfarmer/2dex/hedge/test_close_fix.py`

**Purpose**: End-to-end test verifying no position accumulation

**Test Parameters**:
- Size: $10 notional (small for safety)
- Iterations: 5
- Products: ETH and SOL

**Test Flow**:
1. Check initial positions (should be 0)
2. For each iteration:
   a. Open DN pair position (Long ETH / Short SOL)
   b. Wait 2 seconds
   c. Close both positions using IOC orders
   d. Check positions return to 0
3. Final position check
4. Calculate total margin used

**Acceptance Criteria**:
- Initial positions: 0 (within tolerance)
- After each close: 0 (within tolerance)
- Final positions: 0 (within tolerance)
- Total margin used: ~$4 ($10/5x leverage × 2 positions)
- No position accumulation detected

**Tolerance**:
- SOL: 0.1 (accounts for SOL's 0.1 minimum size increment)
- ETH: 0.001 (accounts for ETH's 0.001 minimum size increment)

**Rollback Plan**: If positions don't close, manually close using Nado dashboard or CLI

---

## Risk Assessment

### Risk 1: Address Change Affects Existing Positions

**Probability**: LOW
**Impact**: MEDIUM
**Mitigation**:
- Existing positions were placed on wrong address, they will remain there
- After fix, new positions will use correct address
- Old positions (on wrong address) should be closed manually before deploying fix
- Or accept them as "orphaned" and write them off

**Rollback**:
- Revert code changes to use old address
- Access orphaned positions using old address method

### Risk 2: Close Order Fails Due to Market Conditions

**Probability**: MEDIUM
**Impact**: HIGH
**Mitigation**:
- IOC orders provide immediate feedback on failure
- Test with small sizes first
- Add retry logic (already present)
- Monitor fill status and log errors

**Rollback**:
- Manually close positions using Nado dashboard
- Revert to POST_ONLY if IOC consistently fails
- Adjust slippage tolerance

### Risk 3: Isolated Margin Calculation Incorrect

**Probability**: LOW
**Impact**: HIGH
**Mitigation**:
- Calculation copied from `place_ioc_order` (which works)
- Same x6 precision used
- Test with small size first
- Add logging to verify margin values

**Rollback**:
- Revert to no isolated_margin parameter
- Accept higher margin usage

### Risk 4: Testnet/Devnet Different from Mainnet

**Probability**: MEDIUM
**Impact**: MEDIUM
**Mitigation**:
- Test on devnet first
- Document any differences found
- Deploy to mainnet with small size ($10)
- Monitor closely for first few trades

**Rollback**:
- Revert changes if mainnet behavior differs
- Adjust code based on mainnet observations

---

## Verification Steps

### Verification 1: Code Review

**Reviewer**: Senior Developer or Code Reviewer
**Checklist**:
- [ ] All instances of `self.client.context.signer.address` replaced with `self.owner`
- [ ] `isolated_margin` calculated correctly with x6 precision
- [ ] Order type changed to IOC
- [ ] Quantity rounding implemented
- [ ] Proper error handling added
- [ ] Logging added for debugging
- [ ] No unintended side effects

### Verification 2: Unit Tests Pass

**Command**: `pytest hedge/tests/test_nado_address_consistency.py -v`

**Expected**: All tests pass

**Verification**:
```bash
cd /Users/botfarmer/2dex
pytest hedge/tests/test_nado_address_consistency.py -v
```

### Verification 3: Integration Tests Pass

**Command**: `pytest hedge/tests/test_nado_position_detection.py -v`

**Expected**: All tests pass

**Verification**:
```bash
cd /Users/botfarmer/2dex
pytest hedge/tests/test_nado_position_detection.py -v
pytest hedge/tests/test_nado_close_order.py -v
```

### Verification 4: Live Test Success

**Command**: `python hedge/test_close_fix.py --size 10 --iter 5`

**Expected Output**:
```
Initial positions - ETH: 0, SOL: 0
Iteration 1/5
Opening positions: Long ETH / Short SOL
ETH order result: status=FILLED, filled=0.XXXX, price=$XXXX
SOL order result: status=FILLED, filled=XX.XX, price=$XXX
Closing positions...
ETH position closed: 0.XXXX @ $XXXX
SOL position closed: XX.XX @ $XXX
Current positions - ETH: 0, SOL: 0
...
Final positions - ETH: 0, SOL: 0
Test completed!
```

**Verification**:
- All iterations complete successfully
- No position accumulation (final positions = 0)
- All orders show FILLED status
- No errors in logs

### Verification 5: Mainnet Deployment (Optional)

**Prerequisites**:
- All tests pass on devnet
- Code review approved
- Rollback plan documented

**Steps**:
1. Deploy to mainnet with small size ($10)
2. Monitor first 5 trades closely
3. Check positions after each close
4. Verify no accumulation
5. Scale up to normal size if successful

---

## Success Metrics

### Metric 1: Position Detection Accuracy

**Target**: 100%
**Measurement**: `get_account_positions()` returns correct size within 0.001 tolerance

**Formula**: `(correct_detections / total_checks) × 100%`

### Metric 2: Close Order Success Rate

**Target**: >95%
**Measurement**: IOC close orders fill immediately

**Formula**: `(filled_orders / total_close_orders) × 100%`

### Metric 3: Position Accumulation Rate

**Target**: 0
**Measurement**: No position accumulation over 5 iterations

**Formula**: `final_position_size` (should be 0)

### Metric 4: Leverage Accuracy

**Target**: 5x ±10%
**Measurement**: Actual leverage used vs expected

**Formula**: `actual_leverage / expected_leverage` (should be ~1.0)

---

## Commit Strategy

### Commit 0: Add Orphaned Position Detection and Cleanup Scripts

**Message**:
```
scripts(nado): Add orphaned position detection and cleanup tools

- Add detect_orphaned_positions.py to identify positions on wrong subaccount
- Add cleanup_orphaned_positions.py to close orphaned positions
- These scripts handle positions created by the context.signer.address bug

Usage:
1. Run detect_orphaned_positions.py to identify orphaned positions
2. If found, run cleanup_orphaned_positions.py to close them
3. Verify cleanup before deploying the fix

Files:
- hedge/scripts/detect_orphaned_positions.py (new)
- hedge/scripts/cleanup_orphaned_positions.py (new)
```

### Commit 1: Fix Subaccount Address

**Message**:
```
fix(nado): Use consistent owner address for position checking

- Change get_account_positions() to use self.owner instead of
  self.client.context.signer.address
- Add debug logging to track address usage
- Ensures orders and positions use same subaccount

This fixes the bug where get_account_positions() always returned 0
because it was checking a different subaccount than where orders
were placed.

File: hedge/exchanges/nado.py
Lines: 981-1005
```

### Commit 2: Fix Close Order Implementation

**Message**:
```
fix(nado): Add isolated_margin and IOC to place_close_order

- Add isolated_margin calculation with x6 precision
- Change order type from POST_ONLY to IOC
- Add quantity rounding to size increment
- Use taker pricing for immediate execution
- Add proper fill status checking
- Reduce expiration to 60 seconds

This ensures close orders execute immediately and use correct
margin calculation, preventing position accumulation.

File: hedge/exchanges/nado.py
Lines: 749-825
```

### Commit 3: Add Tests

**Message**:
```
test(nado): Add tests for address consistency and close orders

- Unit test for address consistency across all methods
- Integration test for position detection
- Integration test for close order execution
- Live test script for multi-iteration verification

Files:
- hedge/tests/test_nado_address_consistency.py
- hedge/tests/test_nado_position_detection.py
- hedge/tests/test_nado_close_order.py
- hedge/test_close_fix.py
```

---

## Implementation Timeline

### Phase 0: Orphaned Position Cleanup (30 minutes)
- Step 0.1: Run detection script - 5 minutes
- Step 0.2: Clean up orphaned positions (if any) - 20 minutes
- Step 0.3: Verify cleanup - 5 minutes

### Phase 1: Code Changes (30 minutes)
- Step 1.1: Verify all instances with grep - 2 minutes
- Step 1.2: Update `get_account_positions()` - 10 minutes
- Step 1.3: Verify other methods - 3 minutes
- Step 2.1: Update `place_close_order` - 15 minutes

### Phase 2: Testing (1 hour)
- Write unit tests with specific assertions - 20 minutes
- Write integration tests - 20 minutes
- Run tests and fix issues - 20 minutes

### Phase 3: Live Testing (30 minutes)
- Run live test with small size - 10 minutes
- Verify results - 10 minutes
- Document findings - 10 minutes

### Phase 4: Deployment (15 minutes)
- Code review - 10 minutes
- Deploy to mainnet - 5 minutes

**Total Time**: ~2.5 hours

---

## Post-Implementation Monitoring

### Monitor For First 24 Hours

1. **Position Accuracy**: Check that `get_account_positions()` returns correct values
2. **Close Success Rate**: Monitor IOC close order fill rate
3. **Leverage Usage**: Verify margin usage stays at expected ~5x
4. **Error Logs**: Check for any new errors in logs
5. **Position Accumulation**: Verify no accumulation over multiple trades

### Alert Thresholds

- Position detection failure rate >5% → Investigate immediately
- Close order failure rate >10% → Revert to old implementation
- Leverage >7x → Investigate potential accumulation
- Any unexpected errors → Log and review

---

## Appendix

### A. Related Files

**Primary File**:
- `/Users/botfarmer/2dex/hedge/exchanges/nado.py`

**Script Files (New)**:
- `/Users/botfarmer/2dex/hedge/scripts/detect_orphaned_positions.py` (new)
- `/Users/botfarmer/2dex/hedge/scripts/cleanup_orphaned_positions.py` (new)

**Test Files**:
- `/Users/botfarmer/2dex/hedge/test_dn_pair.py` (existing test)
- `/Users/botfarmer/2dex/hedge/tests/test_nado_address_consistency.py` (new)
- `/Users/botfarmer/2dex/hedge/tests/test_nado_position_detection.py` (new)
- `/Users/botfarmer/2dex/hedge/tests/test_nado_close_order.py` (new)
- `/Users/botfarmer/2dex/hedge/test_close_fix.py` (new)

### B. Key Methods and Line Numbers

| Method | Lines | Changes |
|--------|-------|---------|
| `__init__` | 47-85 | No changes (sets self.owner) |
| `get_account_positions` | 981-1005 | Fix: use self.owner |
| `place_ioc_order` | 573-700 | No changes (reference for isolated_margin) |
| `place_close_order` | 749-825 | Fix: add isolated_margin, IOC, rounding |
| `cancel_order` | 827-851 | No changes (already uses self.owner) |
| `get_active_orders` | 931-979 | No changes (already uses self.owner) |
| `get_order_info` | 854-929 | No changes (data type reference) |

### C. Reference Code (place_ioc_order for isolated_margin)

Lines 614-622 from nado.py:
```python
# Calculate isolated margin for 5x leverage (margin = notional / leverage)
# SDK requires x6 precision (6 decimal places) for isolated_margin parameter
notional_value = float(str(rounded_quantity)) * float(str(order_price))
leverage = 5.0
isolated_margin = int(notional_value / leverage * 10**6)  # x6 precision: 100.00 -> 100000000
```

### D. SDK Architecture Reference

**Dual Signer Structure**:
```
NadoClient
├── context
│   ├── engine_client.signer.address  ← Used for orders (CORRECT)
│   └── signer.address                 ← Different (BUG when used)
```

**Subaccount Derivation**:
```python
# Correct subaccount (where orders are placed)
correct_subaccount = subaccount_to_hex(
    client.context.engine_client.signer.address,
    subaccount_name
)

# Wrong subaccount (what buggy code was checking)
wrong_subaccount = subaccount_to_hex(
    client.context.signer.address,
    subaccount_name
)
```

**OrderInfo Data Type Specification** (from base.py lines 50-60):
```python
@dataclass
class OrderInfo:
    order_id: str
    side: str
    size: Decimal
    price: Decimal
    status: str
    filled_size: Decimal = 0.0      # Decimal type
    remaining_size: Decimal = 0.0   # Decimal type
    cancel_reason: str = ''
    avg_fill_price: Decimal = 0.0
```

### E. Fee Impact Summary

**Scenario**: 100 DN pair trades per day at $100 notional each

| Order Type | Fee per Trade | Daily Fees | Monthly Fees |
|------------|---------------|------------|--------------|
| POST_ONLY (maker) | $0.04 | $4 | $120 |
| IOC (taker) | $0.10 | $10 | $300 |
| **Difference** | $0.06 | $6 | $180 |

**Conclusion**: $180/month extra in fees is negligible compared to:
- Uncontrolled leverage growth (14x vs 5x)
- Liquidation risk from accumulation
- Manual intervention costs

### F. Glossary

- **Subaccount**: Trading account within the main Nado account
- **Owner Address**: The wallet address that owns the subaccount
- **Engine Client Signer**: Low-level signer used for order placement (correct address)
- **Context Signer**: High-level signer for account management (different from engine signer)
- **Isolated Margin**: Margin allocated to a specific position (not cross-margin)
- **IOC (Immediate-Or-Cancel)**: Order type that executes immediately or cancels
- **POST_ONLY**: Order type that only adds liquidity (never removes it)
- **x18 Precision**: Nado's internal precision for prices and amounts (18 decimals)
- **x6 Precision**: Nado's precision for isolated_margin parameter (6 decimals)
- **Notional Value**: Total value of a position (quantity × price)
- **Leverage**: Ratio of notional value to margin (5x = $20 margin for $100 position)
- **Orphaned Position**: Position placed on wrong subaccount address due to bug

---

## Sign-Off

**Developer**: ______________________
**Date**: ______________________
**Code Reviewer**: ______________________
**Date**: ______________________

**Approval Status**: UPDATED PER CRITIC FEEDBACK - READY FOR IMPLEMENTATION

---

**End of Plan**
