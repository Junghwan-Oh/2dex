# UNWIND Phase Spread Filter Bypass - Alternative Options Analysis

## Problem Statement

DN Bot's UNWIND phase is blocked by spread filter when residual positions exist:

- Bot starts with P=0.2, H=0 (residual position)
- UNWIND phase sees spread -11.05 bps
- `check_arbitrage_opportunity()` returns False
- Infinite loop → bot stuck

**Current Code Location:** `/private/tmp/2dex/perp-dex-tools-original/hedge/DN_alternate_backpack_grvt.py`

```python
# Line 452-480: check_arbitrage_opportunity()
async def check_arbitrage_opportunity(self, direction: str) -> bool:
    if self.min_spread_bps == Decimal("0"):
        return True
    # ... spread calculation
    if spread_bps >= self.min_spread_bps:
        return True
    else:
        return False  # Skip trade

# Line 2290 (UNWIND phase) - Uses spread check, causes blockage
if not await self.check_arbitrage_opportunity(unwind_direction):
    await asyncio.sleep(0.1)
    continue
```

## CRITICAL FINDING: Safety Layer #2 Already Exists!

The bot **ALREADY HAS** a stuck detection mechanism that should handle this:

```python
# Lines 151-153: Safety variables initialization
self.unwind_start_position = Decimal("0")
self.unwind_cycle_count = 0
self.unwind_stuck_threshold = 2  # ← Only 2 cycles!

# Lines 1759-1799: _track_unwind_progress()
def _track_unwind_progress(self, current_position: Decimal) -> bool:
    """Track UNWIND progress and detect if stuck.

    Returns True if UNWIND is making progress, False if stuck.
    """
    # Initialize on first UNWIND cycle
    if self.unwind_cycle_count == 0:
        self.unwind_start_position = abs(current_position)
        self.logger.info(
            f"[SAFETY_LAYER_2] UNWIND tracking started. "
            f"Starting position: {self.unwind_start_position}"
        )
        return True

    self.unwind_cycle_count += 1
    current_magnitude = abs(current_position)

    # Check if position is decreasing
    if current_magnitude < self.unwind_start_position:
        self.unwind_start_position = current_magnitude
        self.unwind_cycle_count = 0
        return True
    else:
        # Not decreasing - check threshold
        if self.unwind_cycle_count >= self.unwind_stuck_threshold:
            self.logger.error(
                f"[SAFETY_LAYER_2] UNWIND STUCK: Position {current_magnitude:.4f} "
                f"has not decreased for {self.unwind_cycle_count} cycles. "
                f"Triggering FORCE CLOSE."
            )
            return False  # ← Triggers force close
        # ... warning logs
        return True

# Lines 1801-1807: _force_unwind_close()
async def _force_unwind_close(self):
    """Force close both exchanges when UNWIND is stuck."""
    self.logger.error("[SAFETY_LAYER_2] Forcing market close of both exchanges...")
    try:
        await self.force_close_all_positions()  # ← DOES bypass spread filter
        # ... verification logic
```

## Root Cause Analysis: Why Safety Layer #2 Fails

### Problem 1: Threshold Too Low (2 cycles)

```python
self.unwind_stuck_threshold = 2  # Line 153
```

With threshold=2:
- **Cycle 0**: Initial tracking starts, returns True
- **Cycle 1**: Position hasn't decreased yet (still waiting for fill), `unwind_cycle_count` becomes 1
- **Cycle 2**: If still stuck, triggers force close

**But this only triggers AFTER the spread check has already blocked the loop!**

### Problem 2: Logic Order - Spread Check Runs BEFORE Stuck Detection

```python
# Lines 2284-2292: UNWIND loop logic
# Safety Layer #2: Track UNWIND progress and detect if stuck
if not self._track_unwind_progress(self.primary_position):
    # UNWIND is stuck - force close and break
    await self._force_unwind_close()
    break

if not await self.check_arbitrage_opportunity(unwind_direction):  # ← Line 2290
    await asyncio.sleep(0.1)
    continue  # ← Loops back to line 2284
```

**The fatal flaw:** The spread check (line 2290) is checked AFTER the stuck detection (line 2285), but when spread check fails, it `continue`s back to the top, which **increments the cycle counter again**!

### Problem 3: Counter Increments on Every Loop Iteration

```python
self.unwind_cycle_count += 1  # Line 1773 - Runs EVERY loop iteration
```

When spread is bad:
- Iteration 1: Stuck detection runs, counter=1, spread check fails → sleep(0.1) → continue
- Iteration 2: Stuck detection runs, counter=2, spread check fails → sleep(0.1) → continue
- **BUT:** The counter hits threshold=2, but the force close only triggers if position hasn't decreased

### Problem 4: Residual Position Edge Case

When bot starts with P=0.2, H=0:
- `unwind_start_position` = 0.2
- Every cycle: position still 0.2 (hasn't decreased)
- After 2 cycles: should trigger force close

**UNLESS** the position decreases slightly (e.g., partial fill to 0.19), then:
- `unwind_start_position` resets to 0.19
- Counter resets to 0
- **Process repeats indefinitely** with tiny incremental fills

### Problem 5: `force_close_all_positions()` DOES Bypass Spread Filter

Looking at lines 1313-1412, `force_close_all_positions()`:
- Uses MARKET orders (line 1370: `place_market_order`)
- Crosses the spread aggressively (line 1366: "crossing spread")
- **NO spread check performed**

So the safety mechanism **should work**... but it's not being triggered reliably.

---

## Why the Bot Gets Stuck (Summary)

1. **Spread check blocks the loop** before it can iterate enough times
2. **Stuck detection counter increments** but threshold is only 2
3. **Partial fills reset the counter**, creating an infinite loop scenario
4. **The bot never reaches consistent "stuck" state** because:
   - Bad spread → skip trade → sleep → continue
   - Counter increments but position stays same
   - After 2 cycles → should force close
   - **But if position changes even slightly**, counter resets

---

## Alternative Options (Beyond Option 1: force_unwind parameter)

### Option 2: Phase-Based Context Object

**Description:** Introduce an `ExecutionContext` dataclass that carries phase information through the call chain.

```python
@dataclass
class ExecutionContext:
    phase: Literal["BUILD", "UNWIND", "CLEANUP"]
    iteration: int
    force_execution: bool = False
    residual_positions: bool = False

async def check_arbitrage_opportunity(
    self, direction: str, context: ExecutionContext
) -> bool:
    # Skip spread check for UNWIND/CLEANUP phases or when forced
    if context.phase in ("UNWIND", "CLEANUP") or context.force_execution:
        return True
    # ... existing spread logic
```

**Usage:**
```python
# BUILD phase
context = ExecutionContext(phase="BUILD", iteration=iteration)
if not await self.check_arbitrage_opportunity(build_direction, context):
    await asyncio.sleep(0.1)
    continue

# UNWIND phase
context = ExecutionContext(phase="UNWIND", iteration=iteration)
if not await self.check_arbitrage_opportunity(unwind_direction, context):
    await asyncio.sleep(0.1)
    continue
```

**Pros vs Option 1:**
- ✅ More explicit and type-safe (dataclass vs boolean)
- ✅ Extensible - can add more context later (iteration number, timestamps, etc.)
- ✅ Self-documenting - clear what phase we're in
- ✅ Future-proof for other phase-specific behaviors

**Cons vs Option 1:**
- ❌ More complex (requires new dataclass)
- ❌ Changes all call sites (BUILD and UNWIND)
- ❌ Over-engineering for current simple need

**Implementation Complexity:** Medium

**Safety Considerations:** High - explicit phase tracking prevents accidental misconfiguration

---

### Option 3: Position-Based Detection (Inference)

**Description:** Let `check_arbitrage_opportunity()` infer phase by inspecting current position state.

```python
async def check_arbitrage_opportunity(
    self, direction: str, allow_unwind_bypass: bool = True
) -> bool:
    # Detect UNWIND phase: we're trying to reduce position
    current_pos = self.primary_client.get_ws_position()

    # If we have position and spread check fails, allow bypass for UNWIND
    if allow_unwind_bypass and abs(current_pos) > 0:
        # We're in UNWIND phase (or residual cleanup)
        # Log warning but proceed
        self.logger.warning(
            f"[ARB] Bypassing spread check for position cleanup (P={current_pos})"
        )
        return True

    # ... existing spread logic
```

**Pros vs Option 1:**
- ✅ No call site changes - works automatically based on position state
- ✅ Handles residual positions gracefully (e.g., bot restart with P=0.2)
- ✅ Minimal code changes

**Cons vs Option 1:**
- ❌ Implicit behavior - harder to understand control flow
- ❌ May bypass spread check unintentionally (e.g., during BUILD if position != 0)
- ❌ Relies on side effect (get_ws_position call) for logic
- ❌ Doesn't distinguish between BUILD and UNWIND clearly

**Implementation Complexity:** Low

**Safety Considerations:** Medium - risk of unintended bypasses if position state is unexpected

---

### Option 4: Separate Methods with Strategy Pattern

**Description:** Split `check_arbitrage_opportunity()` into phase-specific methods.

```python
async def check_build_opportunity(self, direction: str) -> bool:
    """Strict spread check for BUILD phase."""
    if self.min_spread_bps == Decimal("0"):
        return True
    # ... existing spread logic

async def check_unwind_opportunity(self, direction: str) -> bool:
    """Relaxed check for UNWIND - always allow position cleanup."""
    current_pos = self.primary_client.get_ws_position()
    if abs(current_pos) > 0:
        self.logger.info(
            f"[UNWIND] Allowing position cleanup (P={current_pos}, spread check bypassed)"
        )
        return True
    # Optional: still check spread for new trades
    return await self.check_build_opportunity(direction)
```

**Usage:**
```python
# BUILD phase
if not await self.check_build_opportunity(build_direction):
    await asyncio.sleep(0.1)
    continue

# UNWIND phase
if not await self.check_unwind_opportunity(unwind_direction):
    await asyncio.sleep(0.1)
    continue
```

**Pros vs Option 1:**
- ✅ Clear separation of concerns
- ✅ Each method has single responsibility
- ✅ Easy to understand behavior at call site
- ✅ Can evolve independently (e.g., add different logic per phase)

**Cons vs Option 1:**
- ❌ Code duplication (spread logic in both methods)
- ❌ Changes all call sites
- ❌ May need shared private method (`_check_spread_internal()`)

**Implementation Complexity:** Medium

**Safety Considerations:** High - explicit method names prevent confusion

---

### Option 5: Class-Level State Machine

**Description:** Add explicit phase state tracking to the bot class.

```python
from enum import Enum

class BotPhase(Enum):
    INIT = "init"
    BUILD = "build"
    UNWIND = "unwind"
    CLEANUP = "cleanup"
    SHUTDOWN = "shutdown"

class DNHedgeBot:
    def __init__(self, ...):
        # ... existing init
        self.current_phase = BotPhase.INIT

    async def check_arbitrage_opportunity(self, direction: str) -> bool:
        # Bypass spread check for UNWIND and CLEANUP phases
        if self.current_phase in (BotPhase.UNWIND, BotPhase.CLEANUP):
            self.logger.info(
                f"[ARB] Phase={self.current_phase.value}, bypassing spread check"
            )
            return True

        # ... existing spread logic

    async def run(self):
        # BUILD phase
        self.current_phase = BotPhase.BUILD
        while abs(self.primary_client.get_ws_position()) < self.max_position:
            if not await self.check_arbitrage_opportunity(build_direction):
                await asyncio.sleep(0.1)
                continue
            # ...

        # UNWIND phase
        self.current_phase = BotPhase.UNWIND
        while abs(self.primary_client.get_ws_position()) > 0:
            if not await self.check_arbitrage_opportunity(unwind_direction):
                await asyncio.sleep(0.1)
                continue
            # ...
```

**Pros vs Option 1:**
- ✅ Centralized state management
- ✅ Single source of truth for phase
- ✅ Extensible to other behaviors (logging, monitoring, etc.)
- ✅ Debugging friendly (can log phase transitions)
- ✅ No method signature changes

**Cons vs Option 1:**
- ❌ Requires careful state management (must update phase correctly)
- ❌ More invasive (adds state variable to class)
- ❌ Risk of state desynchronization if not updated properly

**Implementation Complexity:** Medium-High

**Safety Considerations:** Medium-High - depends on correct state transitions, but very powerful once implemented

---

### Option 6: Hybrid Timeout + Force Flag (From Mean Reversion Bot)

**Description:** Adopt the approach from DN_mean_reversion_grvt_backpack_v1.py - use timeout with automatic force-unwind.

```python
async def run(self):
    # ... initialization

    for iteration in range(1, self.iterations + 1):
        # ... BUILD phase (unchanged)

        # ===== UNWIND Phase =====
        self._unwind_start_time = time.time()  # Initialize timeout tracker
        unwind_timeout = 180  # 3 minutes

        while abs(self.primary_client.get_ws_position()) > 0:
            # Check timeout
            elapsed = time.time() - self._unwind_start_time
            force_unwind = elapsed > unwind_timeout

            if force_unwind:
                self.logger.warning(
                    f"[UNWIND] Timeout ({elapsed:.0f}s), forcing close without spread check"
                )
            else:
                # Normal spread check
                if not await self.check_arbitrage_opportunity(unwind_direction):
                    await asyncio.sleep(0.1)
                    continue
                # Reset timeout on successful check
                self._unwind_start_time = time.time()

            # Execute trade (either forced or normal)
            success, _, _ = await self.execute_dn_cycle(unwind_direction)
            # ...
```

**Pros vs Option 1:**
- ✅ Proven solution (already working in mean reversion bot)
- ✅ No method signature changes
- ✅ Graceful degradation (wait for good spread, then force if timeout)
- ✅ Prevents infinite loops while still preferring good fills
- ✅ Handles both transient spread issues and persistent problems

**Cons vs Option 1:**
- ❌ Doesn't immediately solve residual position issue (still waits up to 3 min)
- ❌ Adds timeout configuration
- ❌ More complex logic (timeout tracking, reset on success)

**Implementation Complexity:** Low-Medium

**Safety Considerations:** High - balanced approach, gives market time to improve while guaranteeing exit

---

### Option 7: FIX Safety Layer #2 (NEW - Root Cause Fix)

**Description:** Fix the existing stuck detection mechanism instead of adding bypass logic.

**Problem:** Current implementation has 3 critical flaws:

1. **Threshold too low** (2 cycles) - triggers too early or not at all
2. **Logic order** - spread check blocks before stuck detection can complete
3. **Counter resets on any position change** - prevents reliable stuck detection

**Solution:**

```python
# Option 7A: Increase threshold and fix logic
self.unwind_stuck_threshold = 10  # Line 153 - Increase from 2 to 10

# Option 7B: Track consecutive failures separately
self.unwind_spread_fail_count = 0  # New variable
self.unwind_spread_fail_threshold = 5  # New variable

# In UNWIND loop (around line 2290):
if not await self.check_arbitrage_opportunity(unwind_direction):
    self.unwind_spread_fail_count += 1
    if self.unwind_spread_fail_count >= self.unwind_spread_fail_threshold:
        self.logger.error(
            f"[SAFETY_LAYER_2] Spread check failed {self.unwind_spread_fail_count} times. "
            f"Forcing close without spread check."
        )
        await self._force_unwind_close()
        break
    await asyncio.sleep(0.1)
    continue

# Reset on successful trade
self.unwind_spread_fail_count = 0

# Option 7C: Add timeout-based force close (hybrid approach)
unwind_start_time = time.time()
unwind_timeout = 180  # 3 minutes

# In UNWIND loop:
if time.time() - unwind_start_time > unwind_timeout:
    self.logger.error(f"[SAFETY_LAYER_2] UNWIND timeout ({unwind_timeout}s), forcing close")
    await self._force_unwind_close()
    break
```

**Pros:**
- ✅ Uses existing infrastructure (minimal new code)
- ✅ Fixes root cause instead of working around it
- ✅ Maintains existing safety layer architecture
- ✅ No method signature changes
- ✅ Multiple implementation options (7A, 7B, 7C)

**Cons:**
- ❌ Requires careful testing of threshold values
- ❌ May need tuning for different market conditions
- ❌ Still relies on `force_close_all_positions()` working correctly

**Implementation Complexity:** Low (for 7A), Low-Medium (for 7B/7C)

**Safety Considerations:** Very High - fixes the safety mechanism that should already be working

---

## Comparison Matrix

| Option | Complexity | Safety | Call Site Changes | Invasiveness | Flexibility | Immediate Fix | Addresses Root Cause |
|--------|-----------|--------|-------------------|--------------|-------------|--------------|---------------------|
| **Option 1: force_unwind param** | Low | High | All sites | Low | Low | ✅ Yes | ❌ No (workaround) |
| **Option 2: Context object** | Medium | High | All sites | Medium | High | ✅ Yes | ❌ No (workaround) |
| **Option 3: Position inference** | Low | Medium | None | Low | Low | ✅ Yes | ❌ No (workaround) |
| **Option 4: Separate methods** | Medium | High | All sites | Medium | Medium | ✅ Yes | ❌ No (workaround) |
| **Option 5: State machine** | Medium-High | Medium-High | None | High | Very High | ✅ Yes | ❌ No (workaround) |
| **Option 6: Timeout (mean reversion)** | Low-Medium | Very High | None | Low | Medium | ⚠️ Delayed (up to 3 min) | ⚠️ Partially |
| **Option 7A: Fix threshold** | **Low** | **Very High** | **None** | **Very Low** | **Low** | **✅ Yes** | **✅ Yes** |
| **Option 7B: Spread fail counter** | **Low-Medium** | **Very High** | **None** | **Low** | **Medium** | **✅ Yes** | **✅ Yes** |
| **Option 7C: Timeout force close** | **Low** | **Very High** | **None** | **Low** | **Medium** | ⚠️ Delayed | **✅ Yes** |

---

## Recommendations

### **Option 7 (Fix Safety Layer #2) - HIGHLY RECOMMENDED**

**Why:** This fixes the actual problem instead of adding workarounds:

1. **Safety Layer #2 already exists** and should work
2. **`force_close_all_positions()` already bypasses spread filter** (uses market orders)
3. **Root cause is threshold/logic bugs**, not missing functionality
4. **Minimal code changes** - just fix thresholds or add counter
5. **Maintains existing architecture** - no new bypass mechanisms needed

**Specific Recommendations:**

- **Option 7B (Spread fail counter)**: Best balance of reliability and simplicity
  - Tracks consecutive spread check failures
  - Triggers force close after N failures (e.g., 5)
  - Resets on successful trade
  - Clear indicator of when and why force close happened

- **Option 7C (Timeout)**: Good fallback option
  - Similar to Option 6 but integrated into Safety Layer #2
  - 180 second timeout guarantees exit
  - Can combine with Option 7B for belt-and-suspenders

### **Option 1 (force_unwind param) - Recommended for Quick Fix**

**Why:**
- Simplest implementation
- Direct solution to the stated problem
- Easy to understand and maintain
- Can be combined with Option 7 later

**Best for:** Quick deployment, minimal code changes

### **Option 5 (State machine) - Recommended for Long-term Architecture**

**Why:**
- Most powerful and extensible
- Enables other phase-specific optimizations
- Better debugging and monitoring
- Foundation for future enhancements

**Best for:** Major refactoring, new bot development

### **Not Recommended:**

- **Option 2 (Context object):** Over-engineering for current needs
- **Option 3 (Position inference):** Too implicit, hard to debug
- **Option 4 (Separate methods):** Code duplication, less flexible than state machine
- **Option 6 (Timeout):** Good, but Option 7C is better (integrated into existing safety layer)

---

## Implementation Priority

1. **Immediate fix:** Option 7B (fix Safety Layer #2 with spread fail counter)
2. **Short-term (if 7B insufficient):** Option 7C (add timeout as backup)
3. **Medium-term (architecture):** Option 5 (state machine) for broader phase tracking
4. **Long-term:** Consider combining Options 7B, 7C, and 5 for maximum robustness

---

## Code References

**Main File:** `/private/tmp/2dex/perp-dex-tools-original/hedge/DN_alternate_backpack_grvt.py`

**Key Locations:**
- Lines 151-153: Safety variables initialization (`unwind_stuck_threshold = 2`)
- Lines 452-480: `check_arbitrage_opportunity()` - spread check that blocks UNWIND
- Lines 1759-1799: `_track_unwind_progress()` - stuck detection logic
- Lines 1801-1825: `_force_unwind_close()` - force close handler
- Lines 2284-2292: UNWIND loop - stuck detection + spread check logic
- Lines 1313-1412: `force_close_all_positions()` - **DOES bypass spread filter** (uses market orders)

**Reference Implementation:** `/private/tmp/2dex/perp-dex-tools-original/hedge/DN_mean_reversion_grvt_backpack_v1.py`
- Lines 1433-1467: Timeout-based force_unwind implementation

---

## Next Steps

After Critic review, proceed to:
1. **Select Option 7B (or 7A/7C)** as primary fix
2. Add Option 1 as fallback if needed
3. Create implementation plan with specific threshold values
4. Architect to design selected approach
5. Implement and test with residual position scenarios

---

## Critical Questions for Critic

1. **Is Option 7B sufficient**, or should we combine 7B + 7C (counter + timeout)?
2. **What should the threshold be?** Current is 2, recommended is 5-10 for counter, 180s for timeout
3. **Should we add Option 1 (force_unwind param)** as belt-and-suspenders, or is 7B enough?
4. **Is the existing `force_close_all_positions()` reliable**, or does it need enhancement too?
